//-----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation.  All Rights Reserved.
//
//-----------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using System.Linq;
using System.Numerics;
using System.IO;
using System.Diagnostics.Contracts;
using Bpl = Microsoft.Boogie;
using System.Text;


namespace Microsoft.Dafny {
  public class Compiler {
    public Compiler(ErrorReporter reporter) {
      Reporter = reporter;
    }

    Stack<StringBuilder> copyInstrWriters = new Stack<StringBuilder>(); // a buffer that stores copy instructions generated by letExpr that uses out param.
    Method enclosingMethod;  // non-null when a method body is being translated

    FreshIdGenerator idGenerator = new FreshIdGenerator();

    static FreshIdGenerator compileNameIdGenerator = new FreshIdGenerator();
    public static string FreshId() {
      return compileNameIdGenerator.FreshNumericId();
    }

    Dictionary<Expression, int> uniqueAstNumbers = new Dictionary<Expression, int>();
    int GetUniqueAstNumber(Expression expr) {
      Contract.Requires(expr != null);
      int n;
      if (!uniqueAstNumbers.TryGetValue(expr, out n)) {
        n = uniqueAstNumbers.Count;
        uniqueAstNumbers.Add(expr, n);
      }
      return n;
    }

    public ErrorReporter Reporter;

    void Error(Bpl.IToken tok, string msg, TextWriter wr, params object[] args) {
      Contract.Requires(msg != null);
      Contract.Requires(args != null);

      Reporter.Error(MessageSource.Compiler, tok, msg, args);
      if (wr != null) {
        wr.WriteLine("/* {0} */", string.Format("Compilation error: " + msg, args));
      }
    }

    void ReadRuntimeSystem(TextWriter wr) {
      string codebase = cce.NonNull(System.IO.Path.GetDirectoryName(cce.NonNull(System.Reflection.Assembly.GetExecutingAssembly().Location)));
      string path = System.IO.Path.Combine(codebase, "DafnyRuntime.cs");
      using (TextReader rd = new StreamReader(new FileStream(path, System.IO.FileMode.Open, System.IO.FileAccess.Read))) {
        while (true) {
          string s = rd.ReadLine();
          if (s == null)
            return;
          wr.WriteLine(s);
        }
      }
    }

    void EmitDafnySourceAttribute(Program program, TextWriter wr) {
      Contract.Requires(program != null);

      wr.WriteLine("[assembly: DafnyAssembly.DafnySourceAttribute(@\"");

      var strwr = new StringWriter();
      strwr.NewLine = wr.NewLine;
      new Printer(strwr, DafnyOptions.PrintModes.Everything).PrintProgram(program, true);

      wr.Write(strwr.GetStringBuilder().Replace("\"", "\"\"").ToString());
      wr.WriteLine("\")]");
      wr.WriteLine();
    }

    readonly int IndentAmount = 2;
    void Indent(int ind, TextWriter wr) {
      Contract.Requires(0 <= ind);
      string spaces = "          ";
      for (; spaces.Length < ind; ind -= spaces.Length) {
        wr.Write(spaces);
      }
      wr.Write(spaces.Substring(0, ind));
    }

    public void Compile(Program program, TextWriter wr) {
      Contract.Requires(program != null);
      wr.WriteLine("// Dafny program {0} compiled into C#", program.Name);
      wr.WriteLine("// To recompile, use 'csc' with: /r:System.Numerics.dll");
      wr.WriteLine("// and choosing /target:exe or /target:library");
      wr.WriteLine("// You might also want to include compiler switches like:");
      wr.WriteLine("//     /debug /nowarn:0164 /nowarn:0219 /nowarn:1717");
      wr.WriteLine();
      wr.WriteLine("using System;");
      wr.WriteLine("using System.Numerics;");
      EmitDafnySourceAttribute(program, wr);

      if (!DafnyOptions.O.UseRuntimeLib) {
        ReadRuntimeSystem(wr);
      }

      CompileBuiltIns(program.BuiltIns, wr);

      foreach (ModuleDefinition m in program.CompileModules) {
        if (m.IsAbstract) {
          // the purpose of an abstract module is to skip compilation
          continue;
        }
        int indent = 0;
        if (!m.IsDefaultModule) {
          wr.WriteLine("namespace @{0} {{", m.CompileName);
        } else {
          wr.WriteLine("namespace @__default {");
        }
        indent += IndentAmount;
        foreach (TopLevelDecl d in m.TopLevelDecls) {
          bool compileIt = true;
          if (Attributes.ContainsBool(d.Attributes, "compile", ref compileIt) && !compileIt) {
            continue;
          }
          wr.WriteLine();
          if (d is OpaqueTypeDecl) {
            var at = (OpaqueTypeDecl)d;
            Error(d.tok, "Opaque type ('{0}') cannot be compiled", wr, at.FullName);
          } else if (d is TypeSynonymDecl) {
            var sst = d as SubsetTypeDecl;
            if (sst != null && sst.WitnessKind == SubsetTypeDecl.WKind.Compiled) {
              Indent(indent, wr);
              wr.Write("public class @{0}", sst.CompileName);
              if (sst.TypeArgs.Count != 0) {
                wr.Write("<{0}>", TypeParameters(sst.TypeArgs));
              }
              wr.WriteLine(" {");
              Indent(indent + IndentAmount, wr);
              wr.Write("public static readonly {0} Witness = ", TypeName(sst.Rhs, wr, sst.tok));
              TrExpr(sst.Witness, wr, false);
              wr.WriteLine(";");
              Indent(indent, wr);
              wr.WriteLine("}");
            } else {
              // do nothing, just bypass type synonyms and witness-less subset types in the compiler
            }
          } else if (d is NewtypeDecl) {
            var nt = (NewtypeDecl)d;
            Indent(indent, wr);
            wr.WriteLine("public class @{0} {{", nt.CompileName);
            if (nt.NativeType != null) {
              Indent(indent + IndentAmount, wr);
              wr.WriteLine("public static System.Collections.Generic.IEnumerable<{0}> IntegerRange(BigInteger lo, BigInteger hi) {{", nt.NativeType.Name);
              Indent(indent + 2 * IndentAmount, wr);
              wr.WriteLine("for (var j = lo; j < hi; j++) {{ yield return ({0})j; }}", nt.NativeType.Name);
              Indent(indent + IndentAmount, wr);
              wr.WriteLine("}");
            }
            if (nt.WitnessKind == SubsetTypeDecl.WKind.Compiled) { 
              Indent(indent + IndentAmount, wr);
              if (nt.NativeType == null) {
                wr.Write("public static readonly {0} Witness = ", TypeName(nt.BaseType, wr, nt.tok));
                TrExpr(nt.Witness, wr, false);
              } else {
                wr.Write("public static readonly {0} Witness = ({0})(", nt.NativeType.Name);
                TrExpr(nt.Witness, wr, false);
                wr.Write(")");
              }
              wr.WriteLine(";");
            }
            Indent(indent, wr);
            wr.WriteLine("}");
          } else if (d is DatatypeDecl) {
            var dt = (DatatypeDecl)d;
            Indent(indent, wr);
            wr.Write("public abstract class Base_{0}", dt.CompileName);
            if (dt.TypeArgs.Count != 0) {
              wr.Write("<{0}>", TypeParameters(dt.TypeArgs));
            }
            wr.WriteLine(" { }");
            CompileDatatypeConstructors(dt, indent, wr);
            CompileDatatypeStruct(dt, indent, wr);
          } else if (d is IteratorDecl) {
            var iter = (IteratorDecl)d;
            // An iterator is compiled as follows:
            //   public class MyIteratorExample<T>
            //   {
            //     public T q;  // in-parameter
            //     public T x;  // yield-parameter
            //     public int y;  // yield-parameter
            //     IEnumerator<object> _iter;
            //
            //     public void _MyIteratorExample(T q) {
            //       this.q = q;
            //       _iter = TheIterator();
            //     }
            //
            //     public void MoveNext(out bool more) {
            //       more =_iter.MoveNext();
            //     }
            //
            //     private IEnumerator<object> TheIterator() {
            //       // the translation of the body of the iterator, with each "yield" turning into a "yield return null;"
            //       yield break;
            //     }
            //   }

            if (DafnyOptions.O.ForbidNondeterminism && iter.Outs.Count > 0) {
              Error(iter.tok, "since yield parameters are initialized arbitrarily, iterators are forbidden by /definiteAssignment:3 option", wr);
            }

            Indent(indent, wr);
            wr.Write("public class @{0}", iter.CompileName);
            if (iter.TypeArgs.Count != 0) {
              wr.Write("<{0}>", TypeParameters(iter.TypeArgs));
            }
            wr.WriteLine(" {");
            var ind = indent + IndentAmount;
            // here come the fields
            Constructor ct = null;
            foreach (var member in iter.Members) {
              var f = member as Field;
              if (f != null && !f.IsGhost) {
                Indent(ind, wr);
                wr.WriteLine("public {0} @{1} = {2};", TypeName(f.Type, wr, f.tok), f.CompileName, DefaultValue(f.Type, wr, f.tok));
              } else if (member is Constructor) {
                Contract.Assert(ct == null);  // we're expecting just one constructor
                ct = (Constructor)member;
              }
            }
            Contract.Assert(ct != null);  // we do expect a constructor
            Indent(ind, wr); wr.WriteLine("System.Collections.Generic.IEnumerator<object> __iter;");

            // here's the initializer method
            Indent(ind, wr); wr.Write("public void @{0}(", ct.CompileName);
            string sep = "";
            foreach (var p in ct.Ins) {
              if (!p.IsGhost) {
                // here we rely on the parameters and the corresponding fields having the same names
                wr.Write("{0}{1} @{2}", sep, TypeName(p.Type, wr, p.tok), p.CompileName);
                sep = ", ";
              }
            }
            wr.WriteLine(") {");
            foreach (var p in ct.Ins) {
              if (!p.IsGhost) {
                Indent(ind + IndentAmount, wr);
                wr.WriteLine("this.@{0} = @{0};", p.CompileName);
              }
            }
            Indent(ind + IndentAmount, wr); wr.WriteLine("__iter = TheIterator();");
            Indent(ind, wr); wr.WriteLine("}");
            // here are the enumerator methods
            Indent(ind, wr); wr.WriteLine("public void MoveNext(out bool more) { more = __iter.MoveNext(); }");
            Indent(ind, wr); wr.WriteLine("private System.Collections.Generic.IEnumerator<object> TheIterator() {");
            if (iter.Body == null) {
              Error(iter.tok, "Iterator {0} has no body", wr, iter.FullName);
            } else {
              wr.Write(TrStmt(iter.Body, ind + IndentAmount).ToString());
            }
            Indent(ind + IndentAmount, wr); wr.WriteLine("yield break;");
            Indent(ind, wr); wr.WriteLine("}");
            // end of the class
            Indent(indent, wr); wr.WriteLine("}");

          } else if (d is TraitDecl) {
            //writing the trait
            var trait = (TraitDecl)d;
            Indent(indent, wr);
            wr.Write("public interface @{0}", trait.CompileName);
            wr.WriteLine(" {");
            CompileClassMembers(trait, false, indent + IndentAmount, wr);
            Indent(indent, wr); wr.WriteLine("}");

            //writing the _Companion class
            Indent(indent, wr);
            wr.Write("public class @_Companion_{0}", trait.CompileName);
            wr.WriteLine(" {");
            CompileClassMembers(trait, true, indent + IndentAmount, wr);
            Indent(indent, wr); wr.WriteLine("}");
          } else if (d is ClassDecl) {
            var cl = (ClassDecl)d;
            Indent(indent, wr);
            wr.Write("public partial class @{0}", cl.CompileName);
            if (cl.TypeArgs.Count != 0) {
              wr.Write("<{0}>", TypeParameters(cl.TypeArgs));
            }
            string sep = " : ";
            foreach (var trait in cl.TraitsTyp) {
              wr.Write("{0}{1}", sep, TypeName(trait, wr, cl.tok));
              sep = ", ";
            }
            wr.WriteLine(" {");
            CompileClassMembers(cl, false, indent + IndentAmount, wr);
            Indent(indent, wr); wr.WriteLine("}");
          } else if (d is ModuleDecl) {
            // nop
          } else { Contract.Assert(false); }
        }
        if (!m.IsDefaultModule) {
          wr.WriteLine("}} // end of namespace {0}", m.CompileName);
        } else {
          wr.WriteLine("} // end of namespace @__default");
        }
      }
    }

    void CompileBuiltIns(BuiltIns builtIns, TextWriter wr) {
      wr.WriteLine("namespace Dafny {");
      Indent(IndentAmount, wr);
      wr.WriteLine("internal class ArrayHelpers {");
      foreach (var decl in builtIns.SystemModule.TopLevelDecls) {
        if (decl is ArrayClassDecl) {
          int dims = ((ArrayClassDecl)decl).Dims;

          // Here is an overloading of the method name, where there is an initialValue parameter
          // public static T[,] InitNewArray2<T>(T z, BigInteger size0, BigInteger size1) {
          Indent(3 * IndentAmount, wr);
          wr.Write("public static T[");
          RepeatWrite(wr, dims, "", ",");
          wr.Write("] InitNewArray{0}<T>(T z, ", dims);
          RepeatWrite(wr, dims, "BigInteger size{0}", ", ");
          wr.WriteLine(") {");
          // int s0 = (int)size0;
          for (int i = 0; i < dims; i++) {
            Indent(4 * IndentAmount, wr);
            wr.WriteLine("int s{0} = (int)size{0};", i);
          }
          // T[,] a = new T[s0, s1];
          Indent(4 * IndentAmount, wr);
          wr.Write("T[");
          RepeatWrite(wr, dims, "", ",");
          wr.Write("] a = new T[");
          RepeatWrite(wr, dims, "s{0}", ",");
          wr.WriteLine("];");
          // for (int i0 = 0; i0 < s0; i0++)
          //   for (int i1 = 0; i1 < s1; i1++)
          for (int i = 0; i < dims; i++) {
            Indent((4 + i) * IndentAmount, wr);
            wr.WriteLine("for (int i{0} = 0; i{0} < s{0}; i{0}++)", i);
          }
          // a[i0,i1] = z;
          Indent((4 + dims) * IndentAmount, wr);
          wr.Write("a[");
          RepeatWrite(wr, dims, "i{0}", ",");
          wr.WriteLine("] = z;");
          // return a;
          Indent(4 * IndentAmount, wr);
          wr.WriteLine("return a;");
          // }
          Indent(3 * IndentAmount, wr);
          wr.WriteLine("}");  // end of method
        }
      }
      Indent(IndentAmount, wr);
      wr.WriteLine("}");  // end of class Helpers
      wr.WriteLine("}");  // end of namespace
    }

    static void RepeatWrite(TextWriter wr, int times, string template, string separator) {
      Contract.Requires(1 <= times);
      string s = "";
      for (int i = 0; i < times; i++) {
        wr.Write(s);
        wr.Write(template, i);
        s = separator;
      }
    }

    void CompileDatatypeConstructors(DatatypeDecl dt, int indent, TextWriter wr) {
      Contract.Requires(dt != null);

      string typeParams = dt.TypeArgs.Count == 0 ? "" : string.Format("<{0}>", TypeParameters(dt.TypeArgs));
      if (dt is CoDatatypeDecl) {
        // public class Dt__Lazy<T> : Base_Dt<T> {
        //   public delegate Base_Dt<T> Computer();
        //   Computer c;
        //   public Dt__Lazy(Computer c) { this.c = c; }
        //   public Base_Dt<T> Get() { return c(); }
        // }
        Indent(indent, wr);
        wr.WriteLine("public class {0}__Lazy{1} : Base_{0}{1} {{", dt.CompileName, typeParams);
        int ind = indent + IndentAmount;
        Indent(ind, wr);
        wr.WriteLine("public delegate Base_{0}{1} Computer();", dt.CompileName, typeParams);
        Indent(ind, wr);
        wr.WriteLine("Computer c;");
        Indent(ind, wr);
        wr.WriteLine("public {0}__Lazy(Computer c) {{ this.c = c; }}", dt.CompileName);
        Indent(ind, wr);
        wr.WriteLine("public Base_{0}{1} Get() {{ return c(); }}", dt.CompileName, typeParams);
        Indent(indent, wr);
        wr.WriteLine("}");
      }

      int constructorIndex = 0; // used to give each constructor a different
      foreach (DatatypeCtor ctor in dt.Ctors) {
        // class Dt_Ctor<T,U> : Base_Dt<T> {
        //   Fields;
        //   public Dt_Ctor(arguments) {
        //     Fields = arguments;
        //   }
        //   public override bool Equals(object other) {
        //     var oth = other as Dt_Dtor;
        //     return oth != null && equals(_field0, oth._field0) && ... ;
        //   }
        //   public override int GetHashCode() {
        //     return base.GetHashCode();  // surely this can be improved
        //   }
        //   public override string ToString() {  // only for inductive datatypes
        //     // ...
        //   }
        // }
        Indent(indent, wr);
        wr.Write("public class {0}", DtCtorDeclarationName(ctor, dt.TypeArgs));
        wr.WriteLine(" : Base_{0}{1} {{", dt.CompileName, typeParams);
        int ind = indent + IndentAmount;

        int i = 0;
        foreach (Formal arg in ctor.Formals) {
          if (!arg.IsGhost) {
            Indent(ind, wr);
            wr.WriteLine("public readonly {0} @{1};", TypeName(arg.Type, wr, arg.tok), FormalName(arg, i));
            i++;
          }
        }

        Indent(ind, wr);
        wr.Write("public {0}(", DtCtorDeclartionName(ctor));
        WriteFormals("", ctor.Formals, wr);
        wr.WriteLine(") {");
        i = 0;
        foreach (Formal arg in ctor.Formals) {
          if (!arg.IsGhost) {
            Indent(ind + IndentAmount, wr);
            wr.WriteLine("this.@{0} = @{0};", FormalName(arg, i));
            i++;
          }
        }
        Indent(ind, wr); wr.WriteLine("}");

        // Equals method
        Indent(ind, wr); wr.WriteLine("public override bool Equals(object other) {");
        Indent(ind + IndentAmount, wr);
        wr.Write("var oth = other as {0}", DtCtorName(ctor, dt.TypeArgs));
        wr.WriteLine(";");
        Indent(ind + IndentAmount, wr);
        wr.Write("return oth != null");
        i = 0;
        foreach (Formal arg in ctor.Formals) {
          if (!arg.IsGhost) {
            string nm = FormalName(arg, i);
            if (arg.Type.IsDatatype || arg.Type.IsTypeParameter || arg.Type.SupportsEquality) {
              wr.Write(" && this.@{0}.Equals(oth.@{0})", nm);
            } else {
              wr.Write(" && this.@{0} == oth.@{0}", nm);
            }
            i++;
          }
        }
        wr.WriteLine(";");
        Indent(ind, wr); wr.WriteLine("}");

        // GetHashCode method (Uses the djb2 algorithm)
        Indent(ind, wr); wr.WriteLine("public override int GetHashCode() {");
        Indent(ind + IndentAmount, wr); wr.WriteLine("ulong hash = 5381;");
        Indent(ind + IndentAmount, wr); wr.WriteLine("hash = ((hash << 5) + hash) + {0};", constructorIndex);
        i = 0;
        foreach (Formal arg in ctor.Formals) {
          if (!arg.IsGhost) {
            string nm = FormalName(arg, i);
            Indent(ind + IndentAmount, wr); wr.WriteLine("hash = ((hash << 5) + hash) + ((ulong)this.@{0}.GetHashCode());", nm);
            i++;
          }
        }
        Indent(ind + IndentAmount, wr); wr.WriteLine("return (int) hash;");
        Indent(ind, wr); wr.WriteLine("}");

        if (dt is IndDatatypeDecl) {
          Indent(ind, wr); wr.WriteLine("public override string ToString() {");
          string nm;
          if (dt is TupleTypeDecl) {
            nm = "";
          } else {
            nm = (dt.Module.IsDefaultModule ? "" : dt.Module.CompileName + ".") + dt.CompileName + "." + ctor.CompileName;
          }
          var tempVar = GenVarName("s", ctor.Formals);
          Indent(ind + IndentAmount, wr); wr.WriteLine("string {0} = \"{1}\";", tempVar, nm);
          if (ctor.Formals.Count != 0) {
            Indent(ind + IndentAmount, wr); wr.WriteLine("{0} += \"(\";", tempVar);
            i = 0;
            foreach (var arg in ctor.Formals) {
              if (!arg.IsGhost) {
                if (i != 0) {
                  Indent(ind + IndentAmount, wr); wr.WriteLine("{0} += \", \";", tempVar);
                }
                Indent(ind + IndentAmount, wr); wr.WriteLine("{0} += @{1}.ToString();", tempVar, FormalName(arg, i));
                i++;
              }
            }
            Indent(ind + IndentAmount, wr); wr.WriteLine("{0} += \")\";", tempVar);
          }
          Indent(ind + IndentAmount, wr); wr.WriteLine("return {0};", tempVar);
          Indent(ind, wr); wr.WriteLine("}");
        }

        Indent(indent, wr); wr.WriteLine("}");
      }
      constructorIndex++;
    }

    // create a varName that is not a duplicate of formals' name
    string GenVarName(string root, List<Formal> formals) {
      bool finished = false;
      while (!finished) {
        finished = true;
        int i = 0;
        foreach (var arg in formals) {
          if (!arg.IsGhost) {
            if (root.Equals(FormalName(arg, i))) {
              root += root;
              finished = false;
            }
            i++;
          }
        }
      }
      return root;
    }

    void CompileDatatypeStruct(DatatypeDecl dt, int indent, TextWriter wr) {
      Contract.Requires(dt != null);

      // public struct Dt<T> : IDatatype{
      //   Base_Dt<T> _d;
      //   public Base_Dt<T> _D {
      //     get {
      //       if (_d == null) {
      //         _d = Default;
      //       } else if (_d is Dt__Lazy<T>) {        // co-datatypes only
      //         _d = ((Dt__Lazy<T>)_d).Get();         // co-datatypes only
      //       }
      //       return _d;
      //     }
      //   }
      //   public Dt(Base_Dt<T> d) { this._d = d; }
      //   static Base_Dt<T> theDefault;
      //   public static Base_Dt<T> Default {
      //     get {
      //       if (theDefault == null) {
      //         theDefault = ...;
      //       }
      //       return theDefault;
      //     }
      //   }
      //   public override bool Equals(object other) {
      //     return other is Dt<T> && _D.Equals(((Dt<T>)other)._D);
      //   }
      //   public override int GetHashCode() { return _D.GetHashCode(); }
      //   public override string ToString() { return _D.ToString(); }  // only for inductive datatypes
      //
      //   public bool is_Ctor0 { get { return _D is Dt_Ctor0; } }
      //   ...
      //
      //   public T0 dtor_Dtor0 { get { return ((DT_Ctor)_D).@Dtor0; } }  // This is in essence what gets generated for the case where the destructor is used in one use constructor
      //   public T0 dtor_Dtor0 { get { var d = _D;                       // This is the general case
      //       if (d is DT_Ctor0) { return ((DT_Ctor0)d).@Dtor0; }
      //       if (d is DT_Ctor1) { return ((DT_Ctor1)d).@Dtor0; }
      //       ...
      //       if (d is DT_Ctor(n-2)) { return ((DT_Ctor(n-2))d).@Dtor0; }
      //       return ((DT_Ctor(n-1))d).@Dtor0;
      //    }}
      //   ...
      // }
      string DtT = dt.CompileName;
      string DtT_TypeArgs = "";
      if (dt.TypeArgs.Count != 0) {
        DtT_TypeArgs = "<" + TypeParameters(dt.TypeArgs) + ">";
        DtT += DtT_TypeArgs;
      }

      Indent(indent, wr);
      wr.WriteLine("public struct @{0} {{", DtT);
      int ind = indent + IndentAmount;

      Indent(ind, wr);
      wr.WriteLine("Base_{0} _d;", DtT);

      Indent(ind, wr);
      wr.WriteLine("public Base_{0} _D {{", DtT);
      Indent(ind + IndentAmount, wr);
      wr.WriteLine("get {");
      Indent(ind + 2 * IndentAmount, wr);
      wr.WriteLine("if (_d == null) {");
      Indent(ind + 3 * IndentAmount, wr);
      wr.WriteLine("_d = Default;");
      if (dt is CoDatatypeDecl) {
        string typeParams = dt.TypeArgs.Count == 0 ? "" : string.Format("<{0}>", TypeParameters(dt.TypeArgs));
        Indent(ind + 2 * IndentAmount, wr);
        wr.WriteLine("}} else if (_d is {0}__Lazy{1}) {{", dt.CompileName, typeParams);
        Indent(ind + 3 * IndentAmount, wr);
        wr.WriteLine("_d = (({0}__Lazy{1})_d).Get();", dt.CompileName, typeParams);
      }
      Indent(ind + 2 * IndentAmount, wr); wr.WriteLine("}");
      Indent(ind + 2 * IndentAmount, wr); wr.WriteLine("return _d;");
      Indent(ind + IndentAmount, wr); wr.WriteLine("}");
      Indent(ind, wr); wr.WriteLine("}");

      Indent(ind, wr);
      wr.WriteLine("public @{0}(Base_{1} d) {{ this._d = d; }}", dt.CompileName, DtT);

      Indent(ind, wr);
      wr.WriteLine("static Base_{0} theDefault;", DtT);

      Indent(ind, wr);
      wr.WriteLine("public static Base_{0} Default {{", DtT);
      Indent(ind + IndentAmount, wr);
      wr.WriteLine("get {");
      Indent(ind + 2 * IndentAmount, wr);
      wr.WriteLine("if (theDefault == null) {");
      Indent(ind + 3 * IndentAmount, wr);
      wr.Write("theDefault = ");

      DatatypeCtor defaultCtor;
      if (dt is IndDatatypeDecl) {
        defaultCtor = ((IndDatatypeDecl)dt).DefaultCtor;
      } else {
        defaultCtor = ((CoDatatypeDecl)dt).Ctors[0];  // pick any one of them (but pick must be the same as in InitializerIsKnown and HasZeroInitializer)
      }
      wr.Write("new {0}", DtCtorName(defaultCtor, dt.TypeArgs));
      wr.Write("(");
      string sep = "";
      foreach (Formal f in defaultCtor.Formals) {
        if (!f.IsGhost) {
          wr.Write("{0}{1}", sep, DefaultValue(f.Type, wr, f.tok));
          sep = ", ";
        }
      }
      wr.Write(")");

      wr.WriteLine(";");
      Indent(ind + 2 * IndentAmount, wr);
      wr.WriteLine("}");
      Indent(ind + 2 * IndentAmount, wr);
      wr.WriteLine("return theDefault;");
      Indent(ind + IndentAmount, wr); wr.WriteLine("}");

      Indent(ind, wr); wr.WriteLine("}");

      Indent(ind, wr); wr.WriteLine("public override bool Equals(object other) {");
      Indent(ind + IndentAmount, wr);
      wr.WriteLine("return other is @{0} && _D.Equals(((@{0})other)._D);", DtT);
      Indent(ind, wr); wr.WriteLine("}");

      Indent(ind, wr);
      wr.WriteLine("public override int GetHashCode() { return _D.GetHashCode(); }");
      if (dt is IndDatatypeDecl) {
        Indent(ind, wr);
        wr.WriteLine("public override string ToString() { return _D.ToString(); }");
      }

      // query properties
      foreach (var ctor in dt.Ctors) {
        //   public bool is_Ctor0 { get { return _D is Dt_Ctor0; } }
        Indent(ind, wr);
        wr.WriteLine("public bool is_{0} {{ get {{ return _D is {1}_{0}{2}; }} }}", ctor.CompileName, dt.CompileName, DtT_TypeArgs);
      }
      if (dt.HasFinitePossibleValues) {
        Indent(ind, wr);
        wr.WriteLine("public static System.Collections.Generic.IEnumerable<@{0}> AllSingletonConstructors {{", DtT);
        Indent(ind + IndentAmount, wr);
        wr.WriteLine("get {");
        foreach (var ctr in dt.Ctors) {
          if (ctr.Formals.Count == 0) {
            Indent(ind + IndentAmount + IndentAmount, wr);
            wr.WriteLine("yield return new @{0}(new {2}_{1}());", DtT, ctr.CompileName, dt.CompileName);
          }
        }
        Indent(ind + IndentAmount + IndentAmount, wr);
        wr.WriteLine("yield break;");
        Indent(ind + IndentAmount, wr);
        wr.WriteLine("}");
        Indent(ind, wr);
        wr.WriteLine("}");
      }

      // destructors
      foreach (var ctor in dt.Ctors) {
        foreach (var dtor in ctor.Destructors) {
          if (dtor.EnclosingCtors[0] == ctor) {
            var arg = dtor.CorrespondingFormals[0];
            if (!arg.IsGhost && arg.HasName) {
              Indent(ind, wr);
              //   public T0 dtor_Dtor0 { get { var d = _D;
              //       if (d is DT_Ctor0) { return ((DT_Ctor0)d).@Dtor0; }
              //       if (d is DT_Ctor1) { return ((DT_Ctor1)d).@Dtor0; }
              //       ...
              //       if (d is DT_Ctor(n-2)) { return ((DT_Ctor(n-2))d).@Dtor0; }
              //       return ((DT_Ctor(n-1))d).@Dtor0;
              //    }}
              wr.Write("public {0} dtor_{1} {{ get {{ var d = _D; ", TypeName(arg.Type, wr, arg.tok), arg.CompileName);
              var n = dtor.EnclosingCtors.Count;
              for (int i = 0; i < n-1; i++) {
                var ctor_i = dtor.EnclosingCtors[i];
                Contract.Assert(arg.CompileName == dtor.CorrespondingFormals[i].CompileName);
                wr.Write("if (d is {0}_{1}{2}) {{ return (({0}_{1}{2})d).@{3}; }} ", dt.CompileName, ctor_i.CompileName, DtT_TypeArgs, arg.CompileName);
              }
              Contract.Assert(arg.CompileName == dtor.CorrespondingFormals[n-1].CompileName);
              wr.WriteLine("return (({0}_{1}{2})d).@{3}; }} }}", dt.CompileName, dtor.EnclosingCtors[n-1].CompileName, DtT_TypeArgs, arg.CompileName);
            }
          }
        }
      }

      Indent(indent, wr);
      wr.WriteLine("}");
    }

    int WriteFormals(string sep, List<Formal/*!*/>/*!*/ formals, TextWriter wr) {
      Contract.Requires(sep != null);
      Contract.Requires(cce.NonNullElements(formals));
      int i = 0;
      foreach (Formal arg in formals) {
        if (!arg.IsGhost) {
          string name = FormalName(arg, i);
          wr.Write("{0}{1}{2} @{3}", sep, arg.InParam ? "" : "out ", TypeName(arg.Type, wr, arg.tok), name);
          sep = ", ";
          i++;
        }
      }
      return i;  // the number of formals written
    }

    string FormalName(Formal formal, int i) {
      Contract.Requires(formal != null);
      Contract.Ensures(Contract.Result<string>() != null);

      return formal.HasName ? formal.CompileName : "_a" + i;
    }

    string DtName(DatatypeDecl decl) {
      var d = (TopLevelDecl)decl;
      return d.Module.IsDefaultModule ? d.CompileName : d.FullCompileName;
    }
    string DtCtorName(DatatypeCtor ctor) {
      Contract.Requires(ctor != null);
      Contract.Ensures(Contract.Result<string>() != null);

      return DtName(ctor.EnclosingDatatype) + "_" + ctor.CompileName;
    }
    string DtCtorDeclartionName(DatatypeCtor ctor) {
      Contract.Requires(ctor != null);
      Contract.Ensures(Contract.Result<string>() != null);

      return ctor.EnclosingDatatype.CompileName + "_" + ctor.CompileName;
    }

    string DtCtorName(DatatypeCtor ctor, List<TypeParameter> typeParams) {
      Contract.Requires(ctor != null);
      Contract.Ensures(Contract.Result<string>() != null);

      var s = DtCtorName(ctor);
      if (typeParams != null && typeParams.Count != 0) {
        s += "<" + TypeParameters(typeParams) + ">";
      }
      return s;
    }
    string DtCtorDeclarationName(DatatypeCtor ctor, List<TypeParameter> typeParams) {
      Contract.Requires(ctor != null);
      Contract.Ensures(Contract.Result<string>() != null);

      var s = DtCtorDeclartionName(ctor);
      if (typeParams != null && typeParams.Count != 0) {
        s += "<" + TypeParameters(typeParams) + ">";
      }
      return s;
    }

    string DtCtorName(DatatypeCtor ctor, List<Type> typeArgs, TextWriter wr) {
      Contract.Requires(ctor != null);
      Contract.Ensures(Contract.Result<string>() != null);

      var s = DtCtorName(ctor);
      if (typeArgs != null && typeArgs.Count != 0) {
        s += "<" + TypeNames(typeArgs, wr, ctor.tok) + ">";
      }
      return s;
    }

    public bool HasMain(Program program) {
      Method mainMethod = null;
      bool hasMain = false;
      foreach (var module in program.Modules()) {
        if (module.IsAbstract) {
          // the purpose of an abstract module is to skip compilation
          continue;
        }
        foreach (var decl in module.TopLevelDecls) {
          var c = decl as ClassDecl;
          if (c != null) {
            foreach (var member in c.Members) {
              var m = member as Method;
              if (m != null && IsMain(m)) {
                if (mainMethod == null) {
                  mainMethod = m;
                  hasMain = true;
                } else {
                  // more than one main in the program
                  Error(m.tok, "More than one method is declared as \"main\". First declaration appeared at {0}.", null, ErrorReporter.TokenToString(mainMethod.tok));
                  hasMain = false;
                }
              }
            }
          }
        }
      }
      return hasMain;
    }

    public static bool IsMain(Method m) {
      // In order to be a legal Main() method, the following must be true:
      //    The method takes no parameters
      //    The method is not a ghost method 
      //    The method has no requires clause 
      //    The method has no modifies clause 
      //    If the method is an instance (that is, non-static) method in a class, then the enclosing class must not declare any constructor
      // Or if a method is annotated with {:main} and the above restrictions apply, except it is allowed to take ghost arguments, 
      //    and it is allowed to have preconditions and modifies.  This lets the programmer add some explicit assumptions about the outside world, 
      //    modeled, for example, via ghost parameters.
      if (!m.IsGhost && m.Name == "Main" && m.TypeArgs.Count == 0 && m.Ins.Count == 0 && m.Outs.Count == 0 && m.Req.Count == 0
            && m.Mod.Expressions.Count == 0 && (m.IsStatic || (((ClassDecl)m.EnclosingClass) == null) || !((ClassDecl)m.EnclosingClass).HasConstructor)) {
        return true;
      } else if (Attributes.Contains(m.Attributes, "main") && !m.IsGhost && m.TypeArgs.Count == 0 && m.Outs.Count == 0
            && (m.IsStatic || (((ClassDecl)m.EnclosingClass) == null) || !((ClassDecl)m.EnclosingClass).HasConstructor)) {
        if (m.Ins.Count == 0) {
          return true;
        } else {
          bool isGhost = true;
          foreach (var arg in m.Ins) {
            if (!arg.IsGhost) {
              isGhost = false;
            }
          }
          return isGhost;
        }
      } else {
        return false;
      }
    }

    void CompileClassMembers(ClassDecl c, bool forCompanionClass, int indent, TextWriter wr) {
      Contract.Requires(c != null);
      Contract.Requires(!forCompanionClass || c is TraitDecl);
      Contract.Requires(0 <= indent);
      foreach (var member in c.InheritedMembers) {
        Contract.Assert(!member.IsStatic);  // only instance members should ever be added to .InheritedMembers
        if (member.IsGhost) {
          // skip
        } else if (member is ConstantField) {
          var cf = (ConstantField)member;
          if (cf.Rhs == null) {
            Contract.Assert(!cf.IsStatic);  // module-level and static const's must have a RHS (enforced by parser)
            Indent(indent, wr);
            wr.WriteLine("public {0} _{1} = {2};", TypeName(cf.Type, wr, cf.tok), cf.CompileName, DefaultValue(cf.Type, wr, cf.tok));
          }
          Indent(indent, wr);
          wr.Write("public {2}{0} @{1}()", TypeName(cf.Type, wr, cf.tok), cf.CompileName, cf.IsStatic ? "static " : "");
          wr.WriteLine("{");
          if (cf.Rhs == null) {
            Indent(indent + IndentAmount, wr);
            wr.WriteLine("return _{0};", cf.CompileName);
          } else {
            CompileReturnBody(cf.Rhs, indent + IndentAmount, wr);
          }
          Indent(indent, wr); wr.WriteLine("}");
        } else if (member is Field) {
          var f = (Field)member;
          // every field is inherited
          Indent(indent, wr);
          wr.WriteLine("public {0} @_{1} = {2};", TypeName(f.Type, wr, f.tok), f.CompileName, DefaultValue(f.Type, wr, f.tok));
          Indent(indent, wr);
          wr.WriteLine("public {0} @{1} {{", TypeName(f.Type, wr, f.tok), f.CompileName);
          Indent(indent + IndentAmount, wr);
          wr.WriteLine("get {{ return this.@_{0}; }}", f.CompileName);
          Indent(indent + IndentAmount, wr);
          wr.WriteLine("set {{ this.@_{0} = value; }}", f.CompileName);
          Indent(indent, wr);
          wr.WriteLine("}");
        } else if (member is Function) {
          var f = (Function)member;
          Contract.Assert(f.Body != null);
          CompileFunction(indent, f, wr);
        } else if (member is Method) {
          var method = (Method)member;
          Contract.Assert(method.Body != null);
          CompileMethod(c, indent, method, wr);
        } else {
          Contract.Assert(false);  // unexpected member
        }
      }
      foreach (MemberDecl member in c.Members) {
        if (member is Field) {
          var f = (Field)member;
          if (f.IsGhost) {
            // emit nothing
          } else if (forCompanionClass) {
            // emit nothing, unless "f" is a static const
            var cf = f as ConstantField;
            if (cf != null && cf.IsStatic) {
              Indent(indent, wr);
              wr.Write("public static {0} @{1}()", TypeName(cf.Type, wr, cf.tok), cf.CompileName);
              wr.WriteLine("{");
              if (cf.Rhs != null) {
                CompileReturnBody(cf.Rhs, indent + IndentAmount, wr);
              } else {
                wr.WriteLine("return {0};", DefaultValue(cf.Type, wr, cf.tok));
              }
              Indent(indent, wr); wr.WriteLine("}");
            }
          } else if (c is TraitDecl) {
            if (f is ConstantField) {
              var cf = (ConstantField)f;
              if (cf.IsStatic) {
                // emit nothing
              } else {
                Indent(indent, wr);
                wr.WriteLine("{0} @{1}();", TypeName(f.Type, wr, cf.tok), f.CompileName);
              }
            } else {
              Indent(indent, wr);
              wr.Write("{0} @{1}", TypeName(f.Type, wr, f.tok), f.CompileName);
              wr.WriteLine(" { get; set; }");
            }
          } else if (f is ConstantField) {
            var cf = (ConstantField)f;
            if (cf.Rhs == null) {
              Indent(indent, wr);
              wr.WriteLine("public {3}{0} _{1} = {2};", TypeName(cf.Type, wr, cf.tok), cf.CompileName, DefaultValue(cf.Type, wr, cf.tok), f.IsStatic ? "static " : "");
            }
            Indent(indent, wr);
            wr.Write("public {2}{0} @{1}()", TypeName(cf.Type, wr, cf.tok), cf.CompileName, f.IsStatic ? "static " : "");
            wr.WriteLine("{");
            if (cf.Rhs == null) {
              Indent(indent + IndentAmount, wr);
              wr.WriteLine("return _{0};", cf.CompileName);
            } else {
              CompileReturnBody(cf.Rhs, indent + IndentAmount, wr);
            }
            Indent(indent, wr); wr.WriteLine("}");
          } else {
            Indent(indent, wr);
            wr.WriteLine("public {0} @{1} = {2};", TypeName(f.Type, wr, f.tok), f.CompileName, DefaultValue(f.Type, wr, f.tok));
          }
        } else if (member is Function) {
          var f = (Function)member;
          if (f.Body == null && !(c is TraitDecl && !f.IsStatic)) {
            // A (ghost or non-ghost) function must always have a body, except if it's an instance function in a trait.
            if (forCompanionClass || Attributes.Contains(f.Attributes, "axiom") || Attributes.Contains(f.Attributes, "extern")) {
              // suppress error message (in the case of "forCompanionClass", the non-forCompanionClass call will produce the error message)
            } else {
              Error(f.tok, "Function {0} has no body", wr, f.FullName);
            }
          } else if (f.IsGhost) {
            // nothing to compile, but we do check for assumes
            if (f.Body == null) {
              Contract.Assert(c is TraitDecl && !f.IsStatic);
            } else {
              var v = new CheckHasNoAssumes_Visitor(this, wr);
              v.Visit(f.Body);
            }
          } else if (c is TraitDecl && !forCompanionClass) {
            // include it, unless it's static
            if (!f.IsStatic) {
              Indent(indent, wr);
              wr.Write("{0} @{1}", TypeName(f.ResultType, wr, f.tok), f.CompileName);
              wr.Write("(");
              WriteFormals("", f.Formals, wr);
              wr.WriteLine(");");
            }
          } else if (forCompanionClass && !f.IsStatic) {
            // companion classes only has static members
          } else {
            CompileFunction(indent, f, wr);
          }
        } else if (member is Method) {
          var m = (Method)member;
          if (m.Body == null && !(c is TraitDecl && !m.IsStatic)) {
            // A (ghost or non-ghost) method must always have a body, except if it's an instance method in a trait.
            if (forCompanionClass || Attributes.Contains(m.Attributes, "axiom") || Attributes.Contains(m.Attributes, "extern")) {
              // suppress error message (in the case of "forCompanionClass", the non-forCompanionClass call will produce the error message)
            } else {
              Error(m.tok, "Method {0} has no body", wr, m.FullName);
            }
          } else if (m.IsGhost) {
            // nothing to compile, but we do check for assumes
            if (m.Body == null) {
              Contract.Assert(c is TraitDecl && !m.IsStatic);
            } else {
              var v = new CheckHasNoAssumes_Visitor(this, wr);
              v.Visit(m.Body);
            }
          } else if (c is TraitDecl && !forCompanionClass) {
            // include it, unless it's static
            if (!m.IsStatic) {
              Indent(indent, wr);
              wr.Write("void @{0}", m.CompileName);
              wr.Write("(");
              int nIns = WriteFormals("", m.Ins, wr);
              WriteFormals(nIns == 0 ? "" : ", ", m.Outs, wr);
              wr.WriteLine(");");
            }
          } else if (forCompanionClass && !m.IsStatic) {
            // companion classes only has static members
          } else {
            CompileMethod(c, indent, m, wr);
          }
        } else {
          Contract.Assert(false); throw new cce.UnreachableException();  // unexpected member
        }
      }
    }

    private void CompileFunction(int indent, Function f, TextWriter wr) {
      Indent(indent, wr);
      wr.Write("public {0}{1} @{2}", f.IsStatic ? "static " : "", TypeName(f.ResultType, wr, f.tok), f.CompileName);
      if (f.TypeArgs.Count != 0) {
        wr.Write("<{0}>", TypeParameters(f.TypeArgs));
      }
      wr.Write("(");
      WriteFormals("", f.Formals, wr);
      wr.WriteLine(") {");
      CompileReturnBody(f.Body, indent + IndentAmount, wr);
      Indent(indent, wr); wr.WriteLine("}");
    }

    private void CompileMethod(ClassDecl c, int indent, Method m, TextWriter wr) {
      Indent(indent, wr);
      wr.Write("public {0}void @{1}", m.IsStatic ? "static " : "", m.CompileName);
      if (m.TypeArgs.Count != 0) {
        wr.Write("<{0}>", TypeParameters(m.TypeArgs));
      }
      wr.Write("(");
      int nIns = WriteFormals("", m.Ins, wr);
      WriteFormals(nIns == 0 ? "" : ", ", m.Outs, wr);
      wr.WriteLine(")");
      Indent(indent, wr); wr.WriteLine("{");
      foreach (Formal p in m.Outs) {
        if (!p.IsGhost) {
          Indent(indent + IndentAmount, wr);
          wr.WriteLine("@{0} = {1};", p.CompileName, DefaultValue(p.Type, wr, p.tok));
        }
      }
      if (m.Body == null) {
        Error(m.tok, "Method {0} has no body", wr, m.FullName);
      } else {
        if (m.IsTailRecursive) {
          if (!m.IsStatic) {
            Indent(indent + IndentAmount, wr); wr.WriteLine("var _this = this;");
          }
          Indent(indent, wr); wr.WriteLine("TAIL_CALL_START: ;");
        }
        Contract.Assert(enclosingMethod == null);
        enclosingMethod = m;
        TrStmtList(m.Body.Body, indent, wr);
        Contract.Assert(enclosingMethod == m);
        enclosingMethod = null;
      }
      Indent(indent, wr); wr.WriteLine("}");

      // allow the Main method to be an instance method
      if (IsMain(m) && (!m.IsStatic || m.CompileName != "Main")) {
        Indent(indent, wr);
        wr.WriteLine("public static void Main(string[] args) {");
        if (!m.IsStatic) {
          Contract.Assert(m.EnclosingClass == c);
          Indent(indent + IndentAmount, wr);
          wr.Write("@{0} b = new @{0}", c.CompileName);
          if (c.TypeArgs.Count != 0) {
            // instantiate every parameter, it doesn't particularly matter how
            wr.Write("<");
            string sep = "";
            for (int i = 0; i < c.TypeArgs.Count; i++) {
              wr.Write("{0}int", sep);
              sep = ", ";
            }
            wr.Write(">");
          }
          wr.WriteLine("();");
          Indent(indent + IndentAmount, wr); wr.WriteLine("b.@{0}();", m.CompileName);
        } else {
          Indent(indent + IndentAmount, wr); wr.WriteLine("@{0}();", m.CompileName);
        }
        Indent(indent, wr); wr.WriteLine("}");
      }
    }

    void TrCasePatternOpt(CasePattern pat, Expression rhs, string rhs_string, int indent, TextWriter wr, bool inLetExprBody) {
      Contract.Requires(pat != null);
      Contract.Requires(pat.Var != null || rhs != null);
      if (pat.Var != null) {
        // The trivial Dafny "pattern" expression
        //    var x := G
        // is translated into C# as:
        // var x := G;
        var bv = pat.Var;
        if (!bv.IsGhost) {
          Indent(indent, wr);
          wr.Write("{0} {1} = ", TypeName(bv.Type, wr, bv.tok), "@" + bv.CompileName);
          if (rhs != null) {
            TrExpr(rhs, wr, inLetExprBody);
          } else {
            wr.Write(rhs_string);
          }
          wr.Write(";\n");
        }
      } else if (pat.Arguments != null) {
        // The Dafny "pattern" expression
        //    var Pattern(x,y) := G
        // is translated into C# as:
        // var tmp := G;
        // var x := dtorX(tmp);
        // var y := dtorY(tmp);
        var ctor = pat.Ctor;
        Contract.Assert(ctor != null);  // follows from successful resolution
        Contract.Assert(pat.Arguments.Count == ctor.Formals.Count);  // follows from successful resolution

        // Create the temporary variable to hold G
        var tmp_name = idGenerator.FreshId("_let_tmp_rhs");
        Indent(indent, wr);
        wr.Write("{0} {1} = ", TypeName(rhs.Type, wr, rhs.tok), tmp_name);
        TrExpr(rhs, wr, inLetExprBody);
        wr.WriteLine(";");

        var k = 0;  // number of non-ghost formals processed
        for (int i = 0; i < pat.Arguments.Count; i++) {
          var arg = pat.Arguments[i];
          var formal = ctor.Formals[i];
          if (formal.IsGhost) {
            // nothing to compile, but do a sanity check
            Contract.Assert(!Contract.Exists(arg.Vars, bv => !bv.IsGhost));
          } else {
            TrCasePatternOpt(arg, null, string.Format("(({0})({1})._D).@{2}", DtCtorName(ctor, ((DatatypeValue)pat.Expr).InferredTypeArgs, wr), tmp_name, FormalName(formal, k)), indent, wr, inLetExprBody);
            k++;
          }
        }
      }
    }

    void ReturnExpr(Expression expr, int indent, TextWriter wr, bool inLetExprBody) {
      Indent(indent, wr);
      wr.Write("return ");
      TrExpr(expr, wr, inLetExprBody);
      wr.WriteLine(";");
    }

    void TrExprOpt(Expression expr, int indent, TextWriter wr, bool inLetExprBody) {
      Contract.Requires(expr != null);
      if (expr is LetExpr) {
        var e = (LetExpr)expr;
        if (e.Exact) {
          for (int i = 0; i < e.LHSs.Count; i++) {
            var lhs = e.LHSs[i];
            if (Contract.Exists(lhs.Vars, bv => !bv.IsGhost)) {
              TrCasePatternOpt(lhs, e.RHSs[i], null, indent, wr, inLetExprBody);
            }
          }
          TrExprOpt(e.Body, indent, wr, inLetExprBody);
        } else {
          // We haven't optimized the other cases, so fallback to normal compilation
          ReturnExpr(e, indent, wr, inLetExprBody);
        }
      } else if (expr is ITEExpr) {
        ITEExpr e = (ITEExpr)expr;
        Indent(indent, wr);
        wr.Write("if (");
        TrExpr(e.Test, wr, inLetExprBody);
        wr.Write(") {\n");
        TrExprOpt(e.Thn, indent + IndentAmount, wr, inLetExprBody);
        Indent(indent, wr);
        wr.WriteLine("} else {");
        TrExprOpt(e.Els, indent + IndentAmount, wr, inLetExprBody);
        Indent(indent, wr);
        wr.WriteLine("}");
      } else if (expr is MatchExpr) {
        var e = (MatchExpr)expr;
        //   var _source = E;
        //   if (source.is_Ctor0) {
        //     FormalType f0 = ((Dt_Ctor0)source._D).a0;
        //     ...
        //     return Body0;
        //   } else if (...) {
        //     ...
        //   } else if (true) {
        //     ...
        //   }
        string source = idGenerator.FreshId("_source");
        Indent(indent, wr);
        wr.Write("{0} {1} = ", TypeName(e.Source.Type, wr, e.Source.tok), source);
        TrExpr(e.Source, wr, inLetExprBody);
        wr.WriteLine(";");

        if (e.Cases.Count == 0) {
          // the verifier would have proved we never get here; still, we need some code that will compile
          wr.Write("throw new System.Exception();");
        } else {
          int i = 0;
          var sourceType = (UserDefinedType)e.Source.Type.NormalizeExpand();
          foreach (MatchCaseExpr mc in e.Cases) {
            //Indent(indent);
            MatchCasePrelude(source, sourceType, cce.NonNull(mc.Ctor), mc.Arguments, i, e.Cases.Count, indent, wr);
            TrExprOpt(mc.Body, indent + IndentAmount, wr, inLetExprBody);
            i++;
          }
          Indent(indent, wr);
          wr.WriteLine("}");
        }
      } else if (expr is StmtExpr) {
        var e = (StmtExpr)expr;
        TrExprOpt(e.E, indent, wr, inLetExprBody);
      } else {
        // We haven't optimized any other cases, so fallback to normal compilation
        ReturnExpr(expr, indent, wr, inLetExprBody);
      }
    }

    void CompileReturnBody(Expression body, int indent, TextWriter wr) {
      Contract.Requires(0 <= indent);
      body = body.Resolved;
      //Indent(indent);
      //wr.Write("return ");
      TrExprOpt(body, indent, wr, false);
      //wr.WriteLine(";");
    }

    // ----- Type ---------------------------------------------------------------------------------

    readonly string DafnySetClass = "Dafny.Set";
    readonly string DafnyMultiSetClass = "Dafny.MultiSet";
    readonly string DafnySeqClass = "Dafny.Sequence";
    readonly string DafnyMapClass = "Dafny.Map";

    NativeType AsNativeType(Type typ) {
      Contract.Requires(typ != null);
      if (typ.AsNewtype != null) {
        return typ.AsNewtype.NativeType;
      } else if (typ.IsBitVectorType) {
        return ((BitvectorType)typ).NativeType;
      }
      return null;
    }

    string TypeName_Companion(Type type, TextWriter wr, Bpl.IToken tok) {
      Contract.Requires(type != null);
      var udt = type as UserDefinedType;
      if (udt != null && udt.ResolvedClass is TraitDecl) {
        string s = udt.FullCompanionCompileName;
        if (udt.TypeArgs.Count != 0) {
          if (udt.TypeArgs.Exists(argType => argType is ObjectType)) {
            Error(udt.tok, "compilation does not support type 'object' as a type parameter; consider introducing a ghost", wr);
          }
          s += "<" + TypeNames(udt.TypeArgs, wr, udt.tok) + ">";
        }
        return s;
      } else {
        return TypeName(type, wr, tok);
      }
    }
    string TypeName(Type type, TextWriter wr, Bpl.IToken tok) {
      Contract.Requires(type != null);
      Contract.Ensures(Contract.Result<string>() != null);

      var xType = type.NormalizeExpand();
      if (xType is TypeProxy) {
        // unresolved proxy; just treat as ref, since no particular type information is apparently needed for this type
        return "object";
      }

      if (xType is BoolType) {
        return "bool";
      } else if (xType is CharType) {
        return "char";
      } else if (xType is IntType || xType is BigOrdinalType) {
        return "BigInteger";
      } else if (xType is RealType) {
        return "Dafny.BigRational";
      } else if (xType is BitvectorType) {
        var t = (BitvectorType)xType;
        return t.NativeType != null ? t.NativeType.Name : "BigInteger";
      } else if (xType.AsNewtype != null) {
        NativeType nativeType = xType.AsNewtype.NativeType;
        if (nativeType != null) {
          return nativeType.Name;
        }
        return TypeName(xType.AsNewtype.BaseType, wr, tok);
      } else if (xType is ObjectType) {
        return "object";
      } else if (xType.IsArrayType) {
        ArrayClassDecl at = xType.AsArrayType;
        Contract.Assert(at != null);  // follows from type.IsArrayType
        Type elType = UserDefinedType.ArrayElementType(xType);
        string name = TypeName(elType, wr, tok) + "[";
        for (int i = 1; i < at.Dims; i++) {
          name += ",";
        }
        return name + "]";
      } else if (xType is UserDefinedType) {
        var udt = (UserDefinedType)xType;
        var s = udt.FullCompileName;
        var rc = udt.ResolvedClass;
        if (DafnyOptions.O.IronDafny &&
            !(xType is ArrowType) &&
            rc != null &&
            rc.Module != null &&
            !rc.Module.IsDefaultModule) {
          s = rc.FullCompileName;
        }
        return TypeName_UDT(s, udt.TypeArgs, wr, udt.tok);
      } else if (xType is SetType) {
        Type argType = ((SetType)xType).Arg;
        if (ComplicatedTypeParameterForCompilation(argType)) {
          Error(tok, "compilation of set<TRAIT> is not supported; consider introducing a ghost", wr);
        }
        return DafnySetClass + "<" + TypeName(argType, wr, tok) + ">";
      } else if (xType is SeqType) {
        Type argType = ((SeqType)xType).Arg;
        if (ComplicatedTypeParameterForCompilation(argType)) {
          Error(tok, "compilation of seq<TRAIT> is not supported; consider introducing a ghost", wr);
        }
        return DafnySeqClass + "<" + TypeName(argType, wr, tok) + ">";
      } else if (xType is MultiSetType) {
        Type argType = ((MultiSetType)xType).Arg;
        if (ComplicatedTypeParameterForCompilation(argType)) {
          Error(tok, "compilation of multiset<TRAIT> is not supported; consider introducing a ghost", wr);
        }
        return DafnyMultiSetClass + "<" + TypeName(argType, wr, tok) + ">";
      } else if (xType is MapType) {
        Type domType = ((MapType)xType).Domain;
        Type ranType = ((MapType)xType).Range;
        if (ComplicatedTypeParameterForCompilation(domType) || ComplicatedTypeParameterForCompilation(ranType)) {
          Error(tok, "compilation of map<TRAIT, _> or map<_, TRAIT> is not supported; consider introducing a ghost", wr);
        }
        return DafnyMapClass + "<" + TypeName(domType, wr, tok) + "," + TypeName(ranType, wr, tok) + ">";
      } else {
        Contract.Assert(false); throw new cce.UnreachableException();  // unexpected type
      }
    }

    string TypeName_UDT(string fullCompileName, List<Type> typeArgs, TextWriter wr, Bpl.IToken tok) {
      Contract.Requires(fullCompileName != null);
      Contract.Requires(typeArgs != null);
      string s = "@" + fullCompileName;
      if (typeArgs.Count != 0) {
        if (typeArgs.Exists(ComplicatedTypeParameterForCompilation)) {
          Error(tok, "compilation does not support trait types as a type parameter; consider introducing a ghost", wr);
        }
        s += "<" + TypeNames(typeArgs, wr, tok) + ">";
      }
      return s;
    }

    bool ComplicatedTypeParameterForCompilation(Type t) {
      Contract.Requires(t != null);
      return t.IsTraitType;
    }

    string/*!*/ TypeNames(List<Type/*!*/>/*!*/ types, TextWriter wr, Bpl.IToken tok) {
      Contract.Requires(cce.NonNullElements(types));
      Contract.Ensures(Contract.Result<string>() != null);
      string res = "";
      string c = "";
      foreach (var t in types) {
        res += c + TypeName(t, wr, tok);
        c = ",";
      }
      return res;
    }

    string/*!*/ TypeParameters(List<TypeParameter/*!*/>/*!*/ targs) {
      Contract.Requires(cce.NonNullElements(targs));
      Contract.Ensures(Contract.Result<string>() != null);

      return Util.Comma(targs, tp => "@" + tp.CompileName);
    }

    /// <summary>
    /// Returns "true" if a value of type "type" can be initialized with the all-zero bit pattern.
    /// </summary>
    public static bool HasZeroInitializer(Type type, Bpl.IToken tok) {
      Contract.Requires(type != null);

      bool hz, ik;
      string dv;
      TypeInitialization(type, null, null, tok, out hz, out ik, out dv);
      return hz;
    }

    /// <summary>
    /// Returns "true" if "type" denotes a type for which a specific value (witness) is known.
    /// </summary>
    public static bool InitializerIsKnown(Type type, Bpl.IToken tok) {
      Contract.Requires(type != null);

      bool hz, ik;
      string dv;
      TypeInitialization(type, null, null, tok, out hz, out ik, out dv);
      return ik;
    }

    string DefaultValue(Type type, TextWriter wr, Bpl.IToken tok) {
      Contract.Requires(type != null);
      Contract.Ensures(Contract.Result<string>() != null);

      bool hz, ik;
      string dv;
      TypeInitialization(type, this, wr, tok, out hz, out ik, out dv);
      return dv;
    }

    /// <summary>
    /// This method returns three things about the given type. Since the three things are related,
    /// it makes sense to compute them side by side.
    ///   hasZeroInitializer - "true" if a value of type "type" can be initialized with the all-zero bit pattern.
    ///   initializerIsKnown - "true" if "type" denotes a type for which a specific value (witness) is known.
    ///   defaultValue - If "compiler" is non-null, "defaultValue" is the C# representation of one possible value of the
    ///                  type (not necessarily the same value as the zero initializer, if any, may give).
    ///                  If "compiler" is null, then "defaultValue" can return as anything.
    /// </summary>
    static void TypeInitialization(Type type, Compiler/*?*/ compiler, TextWriter/*?*/ wr, Bpl.IToken tok, out bool hasZeroInitializer, out bool initializerIsKnown, out string defaultValue) {
      Contract.Requires(type != null);
      Contract.Ensures(!Contract.ValueAtReturn(out hasZeroInitializer) || Contract.ValueAtReturn(out initializerIsKnown));  // hasZeroInitializer ==> initializerIsKnown
      Contract.Ensures(compiler == null || Contract.ValueAtReturn(out defaultValue) != null);

      var xType = type.NormalizeExpandKeepConstraints();
      if (xType is TypeProxy) {
        // unresolved proxy; just treat as bool, since no particular type information is apparently needed for this type
        xType = new BoolType();
      }

      if (xType is BoolType) {
        hasZeroInitializer = true;
        initializerIsKnown = true;
        defaultValue = "false";
        return;
      } else if (xType is CharType) {
        hasZeroInitializer = true;
        initializerIsKnown = true;
        defaultValue = "'D'";
        return;
      } else if (xType is IntType || xType is BigOrdinalType) {
        hasZeroInitializer = true;
        initializerIsKnown = true;
        defaultValue = "BigInteger.Zero";
        return;
      } else if (xType is RealType) {
        hasZeroInitializer = true;
        initializerIsKnown = true;
        defaultValue = "Dafny.BigRational.ZERO";
        return;
      } else if (xType is BitvectorType) {
        var t = (BitvectorType)xType;
        hasZeroInitializer = true;
        initializerIsKnown = true;
        defaultValue = t.NativeType != null ? "0" : "BigInteger.Zero";
        return;
      } else if (xType is ObjectType) {
        hasZeroInitializer = true;
        initializerIsKnown = true;
        defaultValue = "(object)null";
        return;
      } else if (xType is CollectionType) {
        hasZeroInitializer = false;
        initializerIsKnown = true;
        defaultValue = compiler == null ? null : compiler.TypeName(xType, wr, tok) + ".Empty";
        return;
      }

      var udt = (UserDefinedType)xType;
      if (udt.ResolvedParam != null) {
        hasZeroInitializer = udt.ResolvedParam.Characteristics.MustSupportZeroInitialization;
        initializerIsKnown = hasZeroInitializer;
        // If the module is complete, we expect "udt.ResolvedClass == null" at this time. However, it could be that
        // the compiler has already generated an error about this type not being compilable, in which case
        // "udt.ResolvedClass" might be non-null here.
        defaultValue = compiler == null ? null : "default(" + compiler.TypeName_UDT(udt.FullCompileName, udt.TypeArgs, wr, udt.tok) + ")";
        return;
      }
      var cl = udt.ResolvedClass;
      Contract.Assert(cl != null);
      if (cl is OpaqueTypeDecl) {
        hasZeroInitializer = ((OpaqueTypeDecl)cl).TheType.Characteristics.MustSupportZeroInitialization;
        initializerIsKnown = hasZeroInitializer;
        // The compiler should never need to know a "defaultValue" for an opaque type, but this routine may
        // be asked from outside the compiler about one of the other output booleans.
        Contract.Assume(compiler == null);
        defaultValue = null;
        return;
      } else if (cl is NewtypeDecl) {
        var td = (NewtypeDecl)cl;
        if (td.Witness != null) {
          hasZeroInitializer = false;
          initializerIsKnown = true;
          defaultValue = compiler == null ? null : compiler.TypeName_UDT(udt.FullCompileName, udt.TypeArgs, wr, udt.tok) + ".Witness";
          return;
        } else if (td.NativeType != null) {
          hasZeroInitializer = HasZeroInitializer(td.BaseType, udt.tok);
          initializerIsKnown = true;
          defaultValue = "0";
          return;
        } else {
          Contract.Assert(td.WitnessKind != SubsetTypeDecl.WKind.Special);  // this value is never used with NewtypeDecl
          TypeInitialization(td.BaseType, compiler, wr, udt.tok, out hasZeroInitializer, out initializerIsKnown, out defaultValue);
          return;
        }
      } else if (cl is SubsetTypeDecl) {
        var td = (SubsetTypeDecl)cl;
        if (td.Witness != null) {
          hasZeroInitializer = false;
          initializerIsKnown = true;
          defaultValue = compiler == null ? null : compiler.TypeName_UDT(udt.FullCompileName, udt.TypeArgs, wr, udt.tok) + ".Witness";
          return;
        } else if (td.WitnessKind == SubsetTypeDecl.WKind.Special) {
          Contract.Assert(ArrowType.IsPartialArrowTypeName(td.Name) || ArrowType.IsTotalArrowTypeName(td.Name));  // Special is currently used only with partial and total arrows
          if (ArrowType.IsPartialArrowTypeName(td.Name)) {
            // partial arrow
            hasZeroInitializer = true;
            initializerIsKnown = true;
            defaultValue = compiler == null ? null : string.Format("(({0})null)", compiler.TypeName(type, wr, udt.tok));
            return;
          } else {
            // total arrow
            Contract.Assert(udt.TypeArgs.Count == td.TypeArgs.Count);
            Contract.Assert(1 <= udt.TypeArgs.Count);  // the return type is one of the type arguments
            hasZeroInitializer = false;
            bool hz;
            TypeInitialization(udt.TypeArgs.Last(), compiler, wr, udt.tok, out hz, out initializerIsKnown, out defaultValue);
            if (compiler != null && defaultValue != null) {
              // return the lambda expression ((Ty0 x0, Ty1 x1, Ty2 x2) => defaultValue)
              defaultValue = string.Format("(({0}) => {1})",
                Util.Comma(", ", udt.TypeArgs.Count - 1, i => string.Format("{0} x{1}", compiler.TypeName(udt.TypeArgs[i], wr, udt.tok), i)),
                defaultValue);
            }
            return;
          }
        } else {
          TypeInitialization(td.RhsWithArgument(udt.TypeArgs), compiler, wr, udt.tok, out hasZeroInitializer, out initializerIsKnown, out defaultValue);
          return;
        }
      } else if (cl is TypeSynonymDeclBase) {
        hasZeroInitializer = ((TypeSynonymDeclBase)cl).Characteristics.MustSupportZeroInitialization;
        initializerIsKnown = hasZeroInitializer;
        // The compiler should never need to know a "defaultValue" for a(n internal) type synonym, but this routine may
        // be asked from outside the compiler about one of the other output booleans.
        Contract.Assume(compiler == null);
        defaultValue = null;
        return;
      } else if (cl is ClassDecl) {
        hasZeroInitializer = true;
        initializerIsKnown = true;
        defaultValue = compiler == null ? null : string.Format("({0})null", compiler.TypeName(xType, wr, udt.tok));
        return;
      } else if (cl is DatatypeDecl) {
        // --- hasZeroInitializer ---
        hasZeroInitializer = false;  // TODO: improve this one
        // --- initializerIsKnown ---
        if (cl is CoDatatypeDecl) {
          // The constructors of a codatatype may use type arguments that are not "smaller" than "type",
          // in which case recursing on the types of the constructor's formals may lead to an infinite loop
          // here.  If this were important, the code here could be changed to detect such loop, which would
          // let "initializerIsKnown" be computed more precisely.  For now, set it to "true" if the type
          // has a zero initializer.
          initializerIsKnown = hasZeroInitializer;
        } else {
          DatatypeCtor defaultCtor = ((IndDatatypeDecl)cl).DefaultCtor;
          var subst = Resolver.TypeSubstitutionMap(cl.TypeArgs, udt.TypeArgs);
          // Compute:
          //   initializerIsKnown = defaultCtor.Formals.TrueForAll(formal => formal.IsGhost || InitializerIsKnown(Resolver.SubstType(formal.Type, subst)));
          initializerIsKnown = true;
          foreach (var formal in defaultCtor.Formals) {
            if (formal.IsGhost) {
              continue;
            }
            bool hz, ik;
            string dv;
            var ty = Resolver.SubstType(formal.Type, subst);
            TypeInitialization(ty, compiler, wr, udt.tok, out hz, out ik, out dv);
            if (!ik) {
              initializerIsKnown = false;
              break;
            }
          }
        }
        // --- defaultValue ---
        if (compiler == null) {
          defaultValue = null;
        } else {
          var s = "@" + udt.FullCompileName;
          var rc = cl;
          if (DafnyOptions.O.IronDafny &&
              !(xType is ArrowType) &&
              rc != null &&
              rc.Module != null &&
              !rc.Module.IsDefaultModule) {
            s = "@" + rc.FullCompileName;
          }
          if (udt.TypeArgs.Count != 0) {
            s += "<" + compiler.TypeNames(udt.TypeArgs, wr, udt.tok) + ">";
          }
          defaultValue = string.Format("new {0}()", s);
        }
        return;
      } else {
        Contract.Assert(false); throw new cce.UnreachableException();  // unexpected type
      }
    }

    // ----- Stmt ---------------------------------------------------------------------------------

    public class CheckHasNoAssumes_Visitor : BottomUpVisitor
    {
      readonly Compiler compiler;
      TextWriter wr;
      public CheckHasNoAssumes_Visitor(Compiler c, TextWriter wr) {
        Contract.Requires(c != null);
        compiler = c;
        this.wr = wr;
      }
      protected override void VisitOneStmt(Statement stmt) {
        if (stmt is AssumeStmt) {
          compiler.Error(stmt.Tok, "an assume statement cannot be compiled", wr);
        } else if (stmt is AssignSuchThatStmt) {
          var s = (AssignSuchThatStmt)stmt;
          if (s.AssumeToken != null) {
            compiler.Error(stmt.Tok, "an assume statement cannot be compiled", wr);
          }
        } else if (stmt is ForallStmt) {
          var s = (ForallStmt)stmt;
          if (s.Body == null) {
            compiler.Error(stmt.Tok, "a forall statement without a body cannot be compiled", wr);
          }
        } else if (stmt is WhileStmt) {
          var s = (WhileStmt)stmt;
          if (s.Body == null) {
            compiler.Error(stmt.Tok, "a while statement without a body cannot be compiled", wr);
          }
        }
      }
    }

    TextWriter TrStmt(Statement stmt, int indent) {
      Contract.Requires(stmt != null);
      TextWriter wr = new StringWriter();
      if (stmt.IsGhost) {
        var v = new CheckHasNoAssumes_Visitor(this, wr);
        v.Visit(stmt);
        Indent(indent, wr); wr.WriteLine("{ }");
        return wr;
      }
      if (stmt is PrintStmt) {
        PrintStmt s = (PrintStmt)stmt;
        foreach (var arg in s.Args) {
          Indent(indent, wr);
          wr.Write("System.Console.Write(");
          TrExpr(arg, wr, false);
          wr.WriteLine(");");
        }
      } else if (stmt is BreakStmt) {
        var s = (BreakStmt)stmt;
        Indent(indent, wr);
        wr.WriteLine("goto after_{0};", s.TargetStmt.Labels.Data.AssignUniqueId("after_", idGenerator));
      } else if (stmt is ProduceStmt) {
        var s = (ProduceStmt)stmt;
        if (s.hiddenUpdate != null)
          wr.Write(TrStmt(s.hiddenUpdate, indent).ToString());
        Indent(indent, wr);
        if (s is YieldStmt) {
          wr.WriteLine("yield return null;");
        } else {
          wr.WriteLine("return;");
        }
      } else if (stmt is UpdateStmt) {
        var s = (UpdateStmt)stmt;
        var resolved = s.ResolvedStatements;
        if (resolved.Count == 1) {
          wr.Write(TrStmt(resolved[0], indent).ToString());
        } else {
          // multi-assignment
          Contract.Assert(s.Lhss.Count == resolved.Count);
          Contract.Assert(s.Rhss.Count == resolved.Count);
          var lvalues = new List<string>();
          var rhss = new List<string>();
          for (int i = 0; i < resolved.Count; i++) {
            if (!resolved[i].IsGhost) {
              var lhs = s.Lhss[i];
              var rhs = s.Rhss[i];
              if (rhs is HavocRhs) {
                if (DafnyOptions.O.ForbidNondeterminism) {
                  Error(rhs.Tok, "nondeterministic assignment forbidden by /definiteAssignment:3 option", wr);
                }
              } else {
                lvalues.Add(CreateLvalue(lhs, indent, wr));

                string target = idGenerator.FreshId("_rhs");
                rhss.Add(target);
                TrRhs((rhs is ExprRhs ? TypeName(((ExprRhs)rhs).Expr.Type, wr, rhs.Tok) : "var") + " " + target, rhs, indent, wr);
              }
            }
          }
          Contract.Assert(lvalues.Count == rhss.Count);
          for (int i = 0; i < lvalues.Count; i++) {
            Indent(indent, wr);
            wr.WriteLine("{0} = {1};", lvalues[i], rhss[i]);
          }
        }

      } else if (stmt is AssignStmt) {
        AssignStmt s = (AssignStmt)stmt;
        Contract.Assert(!(s.Lhs is SeqSelectExpr) || ((SeqSelectExpr)s.Lhs).SelectOne);  // multi-element array assignments are not allowed
        if (s.Rhs is HavocRhs) {
          if (DafnyOptions.O.ForbidNondeterminism) {
            Error(s.Rhs.Tok, "nondeterministic assignment forbidden by /definiteAssignment:3 option", wr);
          }
        } else {
          var lvalue = CreateLvalue(s.Lhs, indent, wr);
          TrRhs(lvalue, s.Rhs, indent, wr);
        }

      } else if (stmt is AssignSuchThatStmt) {
        var s = (AssignSuchThatStmt)stmt;
        if (DafnyOptions.O.ForbidNondeterminism) {
          Error(s.Tok, "assign-such-that statement forbidden by /definiteAssignment:3 option", wr);
        }
        if (s.AssumeToken != null) {
          // Note, a non-ghost AssignSuchThatStmt may contain an assume
          Error(s.AssumeToken, "an assume statement cannot be compiled", wr);
        } else if (s.MissingBounds != null) {
          foreach (var bv in s.MissingBounds) {
            Error(s.Tok, "this assign-such-that statement is too advanced for the current compiler; Dafny's heuristics cannot find any bound for variable '{0}'", wr, bv.Name);
          }
        } else {
          Contract.Assert(s.Bounds != null);  // follows from s.MissingBounds == null
          TrAssignSuchThat(indent,
            s.Lhss.ConvertAll(lhs => ((IdentifierExpr)lhs.Resolved).Var),  // the resolver allows only IdentifierExpr left-hand sides
            s.Expr, s.Bounds, s.Tok.line, wr, false);
        }

      } else if (stmt is CallStmt) {
        CallStmt s = (CallStmt)stmt;
        wr.Write(TrCallStmt(s, null, indent).ToString());

      } else if (stmt is BlockStmt) {
        Indent(indent, wr); wr.WriteLine("{");
        TrStmtList(((BlockStmt)stmt).Body, indent, wr);
        Indent(indent, wr); wr.WriteLine("}");

      } else if (stmt is IfStmt) {
        IfStmt s = (IfStmt)stmt;
        if (s.Guard == null) {
          if (DafnyOptions.O.ForbidNondeterminism) {
            Error(s.Tok, "nondeterministic if statement forbidden by /definiteAssignment:3 option", wr);
          }
          // we can compile the branch of our choice
          if (s.Els == null) {
            // let's compile the "else" branch, since that involves no work
            // (still, let's leave a marker in the source code to indicate that this is what we did)
            Indent(indent, wr);
            wr.WriteLine("if (!false) { }");
          } else {
            // let's compile the "then" branch
            Indent(indent, wr);
            wr.WriteLine("if (true)");
            wr.Write(TrStmt(s.Thn, indent).ToString());
          }
        } else {
          if (s.IsExistentialGuard && DafnyOptions.O.ForbidNondeterminism) {
            Error(s.Tok, "binding if statement forbidden by /definiteAssignment:3 option", wr);
          }
          Indent(indent, wr); wr.Write("if (");
          TrExpr(s.IsExistentialGuard ? Translator.AlphaRename((ExistsExpr)s.Guard, "eg_d") : s.Guard, wr, false);
          wr.WriteLine(")");

          // We'd like to do "TrStmt(s.Thn, indent)", except we want the scope of any existential variables to come inside the block
          Indent(indent, wr); wr.WriteLine("{");
          if (s.IsExistentialGuard) {
            IntroduceAndAssignBoundVars(indent + IndentAmount, (ExistsExpr)s.Guard, wr);
          }
          TrStmtList(s.Thn.Body, indent, wr);
          Indent(indent, wr); wr.WriteLine("}");

          if (s.Els != null) {
            Indent(indent, wr); wr.WriteLine("else");
            wr.Write(TrStmt(s.Els, indent).ToString());
          }
        }

      } else if (stmt is AlternativeStmt) {
        var s = (AlternativeStmt)stmt;
        if (DafnyOptions.O.ForbidNondeterminism && 2 <= s.Alternatives.Count) {
          Error(s.Tok, "case-based if statement forbidden by /definiteAssignment:3 option", wr);
        }
        Indent(indent, wr);
        foreach (var alternative in s.Alternatives) {
          wr.Write("if (");
          TrExpr(alternative.IsExistentialGuard ? Translator.AlphaRename((ExistsExpr)alternative.Guard, "eg_d") : alternative.Guard, wr, false);
          wr.WriteLine(") {");
          if (alternative.IsExistentialGuard) {
            IntroduceAndAssignBoundVars(indent + IndentAmount, (ExistsExpr)alternative.Guard, wr);
          }
          TrStmtList(alternative.Body, indent, wr);
          Indent(indent, wr);
          wr.Write("} else ");
        }
        wr.WriteLine("{ /*unreachable alternative*/ }");

      } else if (stmt is WhileStmt) {
        WhileStmt s = (WhileStmt)stmt;
        if (s.Body == null) {
          return wr;
        }
        if (s.Guard == null) {
          if (DafnyOptions.O.ForbidNondeterminism) {
            Error(s.Tok, "nondeterministic loop forbidden by /definiteAssignment:3 option", wr);
          }
          Indent(indent, wr);
          wr.WriteLine("while (false) { }");
        } else {
          Indent(indent, wr);
          wr.Write("while (");
          TrExpr(s.Guard, wr, false);
          wr.WriteLine(")");
          wr.Write(TrStmt(s.Body, indent).ToString());
        }

      } else if (stmt is AlternativeLoopStmt) {
        var s = (AlternativeLoopStmt)stmt;
        if (DafnyOptions.O.ForbidNondeterminism) {
          Error(s.Tok, "case-based loop forbidden by /definiteAssignment:3 option", wr);
        }
        if (s.Alternatives.Count != 0) {
          Indent(indent, wr);
          wr.WriteLine("while (true) {");
          int ind = indent + IndentAmount;
          foreach (var alternative in s.Alternatives) {
          }
          Indent(ind, wr);
          foreach (var alternative in s.Alternatives) {
            wr.Write("if (");
            TrExpr(alternative.Guard, wr, false);
            wr.WriteLine(") {");
            TrStmtList(alternative.Body, ind, wr);
            Indent(ind, wr);
            wr.Write("} else ");
          }
          wr.WriteLine("{ break; }");
          Indent(indent, wr);
          wr.WriteLine("}");
        }

      } else if (stmt is ForallStmt) {
        var s = (ForallStmt)stmt;
        if (s.Kind != ForallStmt.BodyKind.Assign) {
          // Call and Proof have no side effects, so they can simply be optimized away.
          return wr;
        } else if (s.BoundVars.Count == 0) {
          // the bound variables just spell out a single point, so the forall statement is equivalent to one execution of the body
          wr.Write(TrStmt(s.Body, indent).ToString());
          return wr;
        }
        var s0 = (AssignStmt)s.S0;
        if (s0.Rhs is HavocRhs) {
          if (DafnyOptions.O.ForbidNondeterminism) {
            Error(s0.Rhs.Tok, "nondeterministic assignment forbidden by /definiteAssignment:3 option", wr);
          }
          // The forall statement says to havoc a bunch of things.  This can be efficiently compiled
          // into doing nothing.
          return wr;
        }
        var rhs = ((ExprRhs)s0.Rhs).Expr;

        // Compile:
        //   forall (w,x,y,z | Range(w,x,y,z)) {
        //     LHS(w,x,y,z) := RHS(w,x,y,z);
        //   }
        // where w,x,y,z have types seq<W>,set<X>,int,bool and LHS has L-1 top-level subexpressions
        // (that is, L denotes the number of top-level subexpressions of LHS plus 1),
        // into:
        //   var ingredients = new List< L-Tuple >();
        //   foreach (W w in sq.UniqueElements) {
        //     foreach (X x in st.Elements) {
        //       for (BigInteger y = Lo; j < Hi; j++) {
        //         for (bool z in Helper.AllBooleans) {
        //           if (Range(w,x,y,z)) {
        //             ingredients.Add(new L-Tuple( LHS0(w,x,y,z), LHS1(w,x,y,z), ..., RHS(w,x,y,z) ));
        //           }
        //         }
        //       }
        //     }
        //   }
        //   foreach (L-Tuple l in ingredients) {
        //     LHS[ l0, l1, l2, ..., l(L-2) ] = l(L-1);
        //   }
        //
        // Note, because the .NET Tuple class only supports up to 8 components, the compiler implementation
        // here supports arrays only up to 6 dimensions.  This does not seem like a serious practical limitation.
        // However, it may be more noticeable if the forall statement supported forall assignments in its
        // body.  To support cases where tuples would need more than 8 components, .NET Tuple's would have to
        // be nested.

        // Temporary names
        var c = idGenerator.FreshNumericId("_ingredients+_tup");
        string ingredients = "_ingredients" + c;
        string tup = "_tup" + c;

        // Compute L
        int L;
        string tupleTypeArgs;
        if (s0.Lhs is MemberSelectExpr) {
          var lhs = (MemberSelectExpr)s0.Lhs;
          L = 2;
          tupleTypeArgs = TypeName(lhs.Obj.Type, wr, lhs.tok);
        } else if (s0.Lhs is SeqSelectExpr) {
          var lhs = (SeqSelectExpr)s0.Lhs;
          L = 3;
          // note, we might as well do the BigInteger-to-int cast for array indices here, before putting things into the Tuple rather than when they are extracted from the Tuple
          tupleTypeArgs = TypeName(lhs.Seq.Type, wr, lhs.tok) + ",int";
        } else {
          var lhs = (MultiSelectExpr)s0.Lhs;
          L = 2 + lhs.Indices.Count;
          if (8 < L) {
            Error(lhs.tok, "compiler currently does not support assignments to more-than-6-dimensional arrays in forall statements", wr);
            return wr;
          }
          tupleTypeArgs = TypeName(lhs.Array.Type, wr, lhs.tok);
          for (int i = 0; i < lhs.Indices.Count; i++) {
            // note, we might as well do the BigInteger-to-int cast for array indices here, before putting things into the Tuple rather than when they are extracted from the Tuple
            tupleTypeArgs += ",int";
          }
        }
        tupleTypeArgs += "," + TypeName(rhs.Type, wr, rhs.tok);

        // declare and construct "ingredients"
        Indent(indent, wr);
        wr.WriteLine("var {0} = new System.Collections.Generic.List<System.Tuple<{1}>>();", ingredients, tupleTypeArgs);

        var n = s.BoundVars.Count;
        Contract.Assert(s.Bounds.Count == n);
        for (int i = 0; i < n; i++) {
          var ind = indent + i * IndentAmount;
          var bound = s.Bounds[i];
          var bv = s.BoundVars[i];
          if (bound is ComprehensionExpr.BoolBoundedPool) {
            Indent(ind, wr);
            wr.Write("foreach (var @{0} in Dafny.Helpers.AllBooleans) {{ ", bv.CompileName);
          } else if (bound is ComprehensionExpr.CharBoundedPool) {
            Indent(ind, wr);
            wr.Write("foreach (var @{0} in Dafny.Helpers.AllChars) {{ ", bv.CompileName);
          } else if (bound is ComprehensionExpr.IntBoundedPool) {
            var b = (ComprehensionExpr.IntBoundedPool)bound;
            Indent(ind, wr);
            if (AsNativeType(bv.Type) != null) {
              wr.Write("foreach (var @{0} in @{1}.IntegerRange(", bv.CompileName, bv.Type.AsNewtype.FullCompileName);
            } else {
              wr.Write("foreach (var @{0} in Dafny.Helpers.IntegerRange(", bv.CompileName);
            }
            var low = SubstituteBound(b, s.Bounds, s.BoundVars, i, true);
            TrExpr(low, wr, false);
            wr.Write(", ");
            var high = SubstituteBound(b, s.Bounds, s.BoundVars, i, false);
            TrExpr(high, wr, false);
            wr.Write(")) { ");
          } else if (bound is ComprehensionExpr.SetBoundedPool) {
            var b = (ComprehensionExpr.SetBoundedPool)bound;
            Indent(ind, wr);
            wr.Write("foreach (var @{0} in (", bv.CompileName);
            TrExpr(b.Set, wr, false);
            wr.Write(").Elements) { ");
          } else if (bound is ComprehensionExpr.SeqBoundedPool) {
            var b = (ComprehensionExpr.SeqBoundedPool)bound;
            Indent(ind, wr);
            wr.Write("foreach (var @{0} in (", bv.CompileName);
            TrExpr(b.Seq, wr, false);
            wr.Write(").UniqueElements) { ");
          } else if (bound is ComprehensionExpr.DatatypeBoundedPool) {
            var b = (ComprehensionExpr.DatatypeBoundedPool)bound;
            wr.Write("foreach (var @{0} in {1}.AllSingletonConstructors) {{", bv.CompileName, TypeName(bv.Type, wr, bv.tok));
          } else {
            Contract.Assert(false); throw new cce.UnreachableException();  // unexpected BoundedPool type
          }
          wr.WriteLine();
        }

        // if (range) {
        //   ingredients.Add(new L-Tuple( LHS0(w,x,y,z), LHS1(w,x,y,z), ..., RHS(w,x,y,z) ));
        // }
        Indent(indent + n * IndentAmount, wr);
        wr.Write("if (");
        foreach (var bv in s.BoundVars) {
          var bvConstraints = Resolver.GetImpliedTypeConstraint(bv, bv.Type);
          TrParenExpr(bvConstraints, wr, false);
          wr.Write(" && ");
        }
        TrParenExpr(s.Range, wr, false);
        wr.WriteLine(") {");

        var indFinal = indent + (n + 1) * IndentAmount;
        Indent(indFinal, wr);
        wr.Write("{0}.Add(new System.Tuple<{1}>(", ingredients, tupleTypeArgs);
        if (s0.Lhs is MemberSelectExpr) {
          var lhs = (MemberSelectExpr)s0.Lhs;
          TrExpr(lhs.Obj, wr, false);
        } else if (s0.Lhs is SeqSelectExpr) {
          var lhs = (SeqSelectExpr)s0.Lhs;
          TrExpr(lhs.Seq, wr, false);
          wr.Write(", (int)(");
          TrExpr(lhs.E0, wr, false);
          wr.Write(")");
        } else {
          var lhs = (MultiSelectExpr)s0.Lhs;
          TrExpr(lhs.Array, wr, false);
          for (int i = 0; i < lhs.Indices.Count; i++) {
            wr.Write(", (int)(");
            TrExpr(lhs.Indices[i], wr, false);
            wr.Write(")");
          }
        }
        wr.Write(", ");
        TrExpr(rhs, wr, false);
        wr.WriteLine("));");

        Indent(indent + n * IndentAmount, wr);
        wr.WriteLine("}");

        for (int i = n; 0 <= --i;) {
          Indent(indent + i * IndentAmount, wr);
          wr.WriteLine("}");
        }

        //   foreach (L-Tuple l in ingredients) {
        //     LHS[ l0, l1, l2, ..., l(L-2) ] = l(L-1);
        //   }
        Indent(indent, wr);
        wr.WriteLine("foreach (var {0} in {1}) {{", tup, ingredients);
        Indent(indent + IndentAmount, wr);
        if (s0.Lhs is MemberSelectExpr) {
          var lhs = (MemberSelectExpr)s0.Lhs;
          wr.WriteLine("{0}.Item1.@{1} = {0}.Item2;", tup, lhs.MemberName);
        } else if (s0.Lhs is SeqSelectExpr) {
          var lhs = (SeqSelectExpr)s0.Lhs;
          wr.WriteLine("{0}.Item1[{0}.Item2] = {0}.Item3;", tup);
        } else {
          var lhs = (MultiSelectExpr)s0.Lhs;
          wr.Write("{0}.Item1[", tup);
          string sep = "";
          for (int i = 0; i < lhs.Indices.Count; i++) {
            wr.Write("{0}{1}.Item{2}", sep, tup, i + 2);
            sep = ", ";
          }
          wr.WriteLine("] = {0}.Item{1};", tup, L);
        }
        Indent(indent, wr);
        wr.WriteLine("}");

      } else if (stmt is MatchStmt) {
        MatchStmt s = (MatchStmt)stmt;
        // Type source = e;
        // if (source.is_Ctor0) {
        //   FormalType f0 = ((Dt_Ctor0)source._D).a0;
        //   ...
        //   Body0;
        // } else if (...) {
        //   ...
        // } else if (true) {
        //   ...
        // }
        if (s.Cases.Count != 0) {
          string source = idGenerator.FreshId("_source");
          Indent(indent, wr);
          wr.Write("{0} {1} = ", TypeName(cce.NonNull(s.Source.Type), wr, s.Source.tok), source);
          TrExpr(s.Source, wr, false);
          wr.WriteLine(";");

          int i = 0;
          var sourceType = (UserDefinedType)s.Source.Type.NormalizeExpand();
          foreach (MatchCaseStmt mc in s.Cases) {
            MatchCasePrelude(source, sourceType, cce.NonNull(mc.Ctor), mc.Arguments, i, s.Cases.Count, indent, wr);
            TrStmtList(mc.Body, indent, wr);
            i++;
          }
          Indent(indent, wr); wr.WriteLine("}");
        }

      } else if (stmt is VarDeclStmt) {
        var s = (VarDeclStmt)stmt;
        foreach (var local in s.Locals) {
          TrLocalVar(local, true, indent, wr);
        }
        if (s.Update != null) {
          wr.Write(TrStmt(s.Update, indent).ToString());
        }

      } else if (stmt is LetStmt) {
        var s = (LetStmt)stmt;
        if (Contract.Exists(s.LHS.Vars, bv => !bv.IsGhost)) {
          TrCasePatternOpt(s.LHS, s.RHS, null, indent, wr, false);
        }
      } else if (stmt is ModifyStmt) {
        var s = (ModifyStmt)stmt;
        if (s.Body != null) {
          wr.Write(TrStmt(s.Body, indent).ToString());
        } else if (DafnyOptions.O.ForbidNondeterminism) {
          Error(s.Tok, "modify statement without a body forbidden by /definiteAssignment:3 option", wr);
        }

      } else {
        Contract.Assert(false); throw new cce.UnreachableException();  // unexpected statement
      }

      return wr;
    }

    private void IntroduceAndAssignBoundVars(int indent, ExistsExpr exists, TextWriter wr) {
      Contract.Requires(0 <= indent);
      Contract.Requires(exists != null);
      Contract.Assume(exists.Bounds != null);  // follows from successful resolution
      Contract.Assert(exists.Range == null);  // follows from invariant of class IfStmt
      foreach (var bv in exists.BoundVars) {
        TrLocalVar(bv, false, indent, wr);
      }
      var ivars = exists.BoundVars.ConvertAll(bv => (IVariable)bv);
      TrAssignSuchThat(indent, ivars, exists.Term, exists.Bounds, exists.tok.line, wr, false);
    }

    private void TrAssignSuchThat(int indent, List<IVariable> lhss, Expression constraint, List<ComprehensionExpr.BoundedPool> bounds, int debuginfoLine, TextWriter wr, bool inLetExprBody) {
      Contract.Requires(0 <= indent);
      Contract.Requires(lhss != null);
      Contract.Requires(constraint != null);
      Contract.Requires(bounds != null);
      // For "i,j,k,l :| R(i,j,k,l);", emit something like:
      //
      // for (BigInteger iterLimit = 5; ; iterLimit *= 2) {
      //   var il$0 = iterLimit;
      //   foreach (L l' in sq.Elements) { l = l';
      //     if (il$0 == 0) { break; }  il$0--;
      //     var il$1 = iterLimit;
      //     foreach (K k' in st.Elements) { k = k';
      //       if (il$1 == 0) { break; }  il$1--;
      //       var il$2 = iterLimit;
      //       j = Lo;
      //       for (;; j++) {
      //         if (il$2 == 0) { break; }  il$2--;
      //         foreach (bool i' in Helper.AllBooleans) { i = i';
      //           if (R(i,j,k,l)) {
      //             goto ASSIGN_SUCH_THAT_<id>;
      //           }
      //         }
      //       }
      //     }
      //   }
      // }
      // throw new Exception("assign-such-that search produced no value"); // a verified program never gets here; however, we need this "throw" to please the C# compiler
      // ASSIGN_SUCH_THAT_<id>: ;
      //
      // where the iterLimit loop can be omitted if lhss.Count == 1 or if all bounds are finite.  Further optimizations could be done, but
      // are omitted for now.
      //
      var n = lhss.Count;
      Contract.Assert(bounds.Count == n);
      var c = idGenerator.FreshNumericId("_ASSIGN_SUCH_THAT_+_iterLimit_");
      var doneLabel = "_ASSIGN_SUCH_THAT_" + c;
      var iterLimit = "_iterLimit_" + c;

      int ind = indent;
      bool needIterLimit = lhss.Count != 1 && bounds.Exists(bnd => !bnd.IsFinite);
      if (needIterLimit) {
        Indent(indent, wr);
        wr.WriteLine("for (var {0} = new BigInteger(5); ; {0} *= 2) {{", iterLimit);
        ind += IndentAmount;
      }

      for (int i = 0; i < n; i++, ind += IndentAmount) {
        var bound = bounds[i];
        var bv = lhss[i];
        if (needIterLimit) {
          Indent(ind, wr);
          wr.WriteLine("var {0}_{1} = {0};", iterLimit, i);
        }
        var tmpVar = idGenerator.FreshId("_assign_such_that_");
        Indent(ind, wr);
        if (bound is ComprehensionExpr.BoolBoundedPool) {
          wr.WriteLine("foreach (var {0} in Dafny.Helpers.AllBooleans) {{ @{1} = {0};", tmpVar, bv.CompileName);
        } else if (bound is ComprehensionExpr.CharBoundedPool) {
          wr.WriteLine("foreach (var {0} in Dafny.Helpers.AllChars) {{ @{1} = {0};", tmpVar, bv.CompileName);
        } else if (bound is ComprehensionExpr.IntBoundedPool) {
          var b = (ComprehensionExpr.IntBoundedPool)bound;
          if (AsNativeType(bv.Type) != null) {
            wr.Write("foreach (var @{0} in @{1}.IntegerRange(", tmpVar, bv.Type.AsNewtype.FullCompileName);
          } else {
            wr.Write("foreach (var @{0} in Dafny.Helpers.IntegerRange(", tmpVar);
          }
          if (b.LowerBound == null) {
            wr.Write("null");
          } else {
            TrExpr(b.LowerBound, wr, inLetExprBody);
          }
          wr.Write(", ");
          if (b.UpperBound == null) {
            wr.Write("null");
          } else {
            TrExpr(b.UpperBound, wr, inLetExprBody);
          }
          wr.WriteLine(")) {{ @{1} = {0};", tmpVar, bv.CompileName);
        } else if (bound is AssignSuchThatStmt.WiggleWaggleBound) {
          wr.WriteLine("foreach (var {0} in Dafny.Helpers.AllIntegers) {{ @{1} = {0};", tmpVar, bv.CompileName);
        } else if (bound is ComprehensionExpr.SetBoundedPool) {
          var b = (ComprehensionExpr.SetBoundedPool)bound;
          wr.Write("foreach (var {0} in (", tmpVar);
          TrExpr(b.Set, wr, inLetExprBody);
          wr.WriteLine(").Elements) {{ @{0} = {1};", bv.CompileName, tmpVar);
        } else if (bound is ComprehensionExpr.SubSetBoundedPool) {
          var b = (ComprehensionExpr.SubSetBoundedPool)bound;
          wr.Write("foreach (var {0} in (", tmpVar);
          TrExpr(b.UpperBound, wr, inLetExprBody);
          wr.WriteLine(").AllSubsets) {{ @{0} = {1};", bv.CompileName, tmpVar);
        } else if (bound is ComprehensionExpr.MapBoundedPool) {
          var b = (ComprehensionExpr.MapBoundedPool)bound;
          wr.Write("foreach (var {0} in (", tmpVar);
          TrExpr(b.Map, wr, inLetExprBody);
          wr.WriteLine(").Domain) {{ @{0} = {1};", bv.CompileName, tmpVar);
        } else if (bound is ComprehensionExpr.SeqBoundedPool) {
          var b = (ComprehensionExpr.SeqBoundedPool)bound;
          wr.Write("foreach (var {0} in (", tmpVar);
          TrExpr(b.Seq, wr, inLetExprBody);
          wr.WriteLine(").Elements) {{ @{0} = {1};", bv.CompileName, tmpVar);
        } else if (bound is ComprehensionExpr.DatatypeBoundedPool) {
          var b = (ComprehensionExpr.DatatypeBoundedPool)bound;
          wr.WriteLine("foreach (var {0} in {1}.AllSingletonConstructors) {{ @{2} = {0};", tmpVar, TypeName(bv.Type, wr, bv.Tok), bv.CompileName);
        } else {
          Contract.Assert(false); throw new cce.UnreachableException();  // unexpected BoundedPool type
        }
        if (needIterLimit) {
          Indent(ind + IndentAmount, wr);
          wr.WriteLine("if ({0}_{1} == 0) {{ break; }}  {0}_{1}--;", iterLimit, i);
        }
      }
      Indent(ind, wr);
      wr.Write("if (");
      TrExpr(constraint, wr, inLetExprBody);
      wr.WriteLine(") {");
      Indent(ind + IndentAmount, wr);
      wr.WriteLine("goto {0};", doneLabel);
      Indent(ind, wr);
      wr.WriteLine("}");
      Indent(indent, wr);
      for (int i = 0; i < n; i++) {
        wr.Write(i == 0 ? "}" : " }");
      }
      wr.WriteLine(needIterLimit ? " }" : "");
      Indent(indent, wr);
      wr.WriteLine("throw new System.Exception(\"assign-such-that search produced no value (line {0})\");", debuginfoLine);
      Indent(indent, wr);
      wr.WriteLine("{0}: ;", doneLabel);
    }

    string CreateLvalue(Expression lhs, int indent, TextWriter wr) {
      lhs = lhs.Resolved;
      if (lhs is IdentifierExpr) {
        var ll = (IdentifierExpr)lhs;
        return "@" + ll.Var.CompileName;
      } else if (lhs is MemberSelectExpr) {
        var ll = (MemberSelectExpr)lhs;
        string obj = idGenerator.FreshId("_obj");
        Indent(indent, wr);
        wr.Write("var {0} = ", obj);
        TrExpr(ll.Obj, wr, false);
        wr.WriteLine(";");
        Contract.Assert(!ll.Member.IsInstanceIndependentConstant);  // instance-independent const's don't have assignment statements
        return string.Format("{0}.@{2}{1}", obj, ll.Member.CompileName, ll.Member is ConstantField ? "_" : "");
      } else if (lhs is SeqSelectExpr) {
        var ll = (SeqSelectExpr)lhs;
        var c = idGenerator.FreshNumericId("_arr+_index");
        string arr = "_arr" + c;
        string index = "_index" + c;
        Indent(indent, wr);
        wr.Write("var {0} = ", arr);
        TrExpr(ll.Seq, wr, false);
        wr.WriteLine(";");
        Indent(indent, wr);
        wr.Write("var {0} = ", index);
        TrExpr(ll.E0, wr, false);
        wr.WriteLine(";");
        return string.Format("{0}[(int){1}]", arr, index);
      } else {
        var ll = (MultiSelectExpr)lhs;
        var c = idGenerator.FreshNumericId("_arr+_index");
        string arr = "_arr" + c;
        Indent(indent, wr);
        wr.Write("var {0} = ", arr);
        TrExpr(ll.Array, wr, false);
        wr.WriteLine(";");
        string fullString = arr + "[";
        string sep = "";
        int i = 0;
        foreach (var idx in ll.Indices) {
          string index = "_index" + i + "_" + c;
          Indent(indent, wr);
          wr.Write("var {0} = ", index);
          TrExpr(idx, wr, false);
          wr.WriteLine(";");
          fullString += sep + "(int)" + index;
          sep = ", ";
          i++;
        }
        return fullString + "]";
      }
    }

    void TrRhs(string target, AssignmentRhs rhs, int indent, TextWriter wr) {
      Contract.Requires(target != null);
      Contract.Requires(!(rhs is HavocRhs));
      Contract.Requires(0 <= indent);
      Contract.Requires(wr != null);

      var tRhs = rhs as TypeRhs;

      // Do the allocation and assign it to _rhs aka _nw
      Indent(indent, wr);
      string nw;
      if (tRhs == null) {
        var eRhs = (ExprRhs)rhs;  // it's not HavocRhs (by the precondition) or TypeRhs (by the "if" test), so it's gotta be ExprRhs
        nw = idGenerator.FreshId("_rhs");
        wr.Write("{0} {1} = ", TypeName(eRhs.Expr.Type, wr, eRhs.Expr.tok), nw);
      } else {
        nw = idGenerator.FreshId("_nw");
        wr.Write("var {0} = ", nw);
      }
      TrAssignmentRhs(rhs, wr);
      wr.WriteLine(";");

      // Proceed with any initialization
      if (tRhs == null) {
        // no further initialization action required
      } else if (tRhs.InitCall != null) {
        wr.Write(TrCallStmt(tRhs.InitCall, nw, indent).ToString());
      } else if (tRhs.ElementInit != null) {
        // Compute the array-initializing function once and for all (as required by the language definition)
        string f = idGenerator.FreshId("_arrayinit");
        Indent(indent, wr);
        wr.Write("var {0} = ", f);
        TrExpr(tRhs.ElementInit, wr, false);
        wr.WriteLine(";");
        // Build a loop nest that will call the initializer for all indicies
        var indicies = Translator.Map(Enumerable.Range(0, tRhs.ArrayDimensions.Count), ii => idGenerator.FreshId("_arrayinit_" + ii));
        for (int d = 0; d < tRhs.ArrayDimensions.Count; d++) {
          Indent(indent + d * IndentAmount, wr);
          wr.WriteLine("for (int {0} = 0; {0} < {1}.{2}; {0}++) {{", indicies[d], nw,
            tRhs.ArrayDimensions.Count == 1 ? "Length" : ("GetLength(" + d + ")"));
        }
        Indent(indent + tRhs.ArrayDimensions.Count * IndentAmount, wr);
        wr.WriteLine("{0}[{2}] = {1}({2});", nw, f, Util.Comma(indicies, si => si));
        for (int d = tRhs.ArrayDimensions.Count; 0 <= --d; ) {
          Indent(indent + d * IndentAmount, wr);
          wr.WriteLine("}");
        }
      } else if (tRhs.InitDisplay != null) {
        var ii = 0;
        foreach (var v in tRhs.InitDisplay) {
          Indent(indent, wr);
          wr.Write("{0}[{1}] = ", nw, ii);
          TrExpr(v, wr, false);
          wr.WriteLine(";");
          ii++;
        }
      }

      // Assign to the final LHS
      Indent(indent, wr);
      wr.WriteLine("{0} = {1};", target, nw);
    }

    TextWriter TrCallStmt(CallStmt s, string receiverReplacement, int indent) {
      Contract.Requires(s != null);
      Contract.Assert(s.Method != null);  // follows from the fact that stmt has been successfully resolved

      StringWriter wr = new StringWriter();
      if (s.Method == enclosingMethod && enclosingMethod.IsTailRecursive) {
        // compile call as tail-recursive

        // assign the actual in-parameters to temporary variables
        var inTmps = new List<string>();
        if (receiverReplacement != null) {
          // TODO:  What to do here?  When does this happen, what does it mean?
        } else if (!s.Method.IsStatic) {

          string inTmp = idGenerator.FreshId("_in");
          inTmps.Add(inTmp);
          Indent(indent, wr);
          wr.Write("var {0} = ", inTmp);
          TrExpr(s.Receiver, wr, false);
          wr.WriteLine(";");
        }
        for (int i = 0; i < s.Method.Ins.Count; i++) {
          Formal p = s.Method.Ins[i];
          if (!p.IsGhost) {
            string inTmp = idGenerator.FreshId("_in");
            inTmps.Add(inTmp);
            Indent(indent, wr);
            wr.Write("var {0} = ", inTmp);
            TrExpr(s.Args[i], wr, false);
            wr.WriteLine(";");
          }
        }
        // Now, assign to the formals
        int n = 0;
        if (!s.Method.IsStatic) {
          Indent(indent, wr);
          wr.WriteLine("_this = {0};", inTmps[n]);
          n++;
        }
        foreach (var p in s.Method.Ins) {
          if (!p.IsGhost) {
            Indent(indent, wr);
            wr.WriteLine("{0} = {1};", p.CompileName, inTmps[n]);
            n++;
          }
        }
        Contract.Assert(n == inTmps.Count);
        // finally, the jump back to the head of the method
        Indent(indent, wr);
        wr.WriteLine("goto TAIL_CALL_START;");

      } else {
        // compile call as a regular call

        var lvalues = new List<string>();
        Contract.Assert(s.Lhs.Count == s.Method.Outs.Count);
        for (int i = 0; i < s.Method.Outs.Count; i++) {
          Formal p = s.Method.Outs[i];
          if (!p.IsGhost) {
            lvalues.Add(CreateLvalue(s.Lhs[i], indent, wr));
          }
        }
        var outTmps = new List<string>();
        for (int i = 0; i < s.Method.Outs.Count; i++) {
          Formal p = s.Method.Outs[i];
          if (!p.IsGhost) {
            string target = idGenerator.FreshId("_out");
            outTmps.Add(target);
            Indent(indent, wr);
            wr.WriteLine("{0} {1};", TypeName(s.Lhs[i].Type, wr, s.Lhs[i].tok), target);
          }
        }
        Contract.Assert(lvalues.Count == outTmps.Count);

        for (int i = 0; i < s.Method.Ins.Count; i++) {
          Formal p = s.Method.Ins[i];
          if (!p.IsGhost) {
          }
        }
        if (receiverReplacement != null) {
          Indent(indent, wr);
          wr.Write("@" + receiverReplacement);
        } else if (s.Method.IsStatic) {
          Indent(indent, wr);
          wr.Write(TypeName_Companion(s.Receiver.Type, wr, s.Tok));
        } else {
          Indent(indent, wr);
          TrParenExpr(s.Receiver, wr, false);
        }
        wr.Write(".@{0}(", s.Method.CompileName);

        string sep = "";
        for (int i = 0; i < s.Method.Ins.Count; i++) {
          Formal p = s.Method.Ins[i];
          if (!p.IsGhost) {
            wr.Write(sep);
            TrExpr(s.Args[i], wr, false);
            sep = ", ";
          }
        }

        foreach (var outTmp in outTmps) {
          wr.Write("{0}out {1}", sep, outTmp);
          sep = ", ";
        }
        wr.WriteLine(");");

        // assign to the actual LHSs
        for (int j = 0; j < lvalues.Count; j++) {
          Indent(indent, wr);
          wr.WriteLine("{0} = {1};", lvalues[j], outTmps[j]);
        }
      }
      return wr;
    }

    /// <summary>
    /// Before calling TrAssignmentRhs(rhs), the caller must have spilled the let variables declared in "rhs".
    /// </summary>
    void TrAssignmentRhs(AssignmentRhs rhs, TextWriter wr) {
      Contract.Requires(rhs != null);
      Contract.Requires(!(rhs is HavocRhs));
      if (rhs is ExprRhs) {
        ExprRhs e = (ExprRhs)rhs;
        TrExpr(e.Expr, wr, false);

      } else {
        TypeRhs tp = (TypeRhs)rhs;
        if (tp.ArrayDimensions == null) {
          wr.Write("new {0}()", TypeName(tp.EType, wr, rhs.Tok));
        } else {
          if (!HasZeroInitializer(tp.EType, rhs.Tok)) {
            wr.Write("Dafny.ArrayHelpers.InitNewArray{0}<{1}>", tp.ArrayDimensions.Count, TypeName(tp.EType, wr, rhs.Tok));
            wr.Write("(");
            wr.Write(DefaultValue(tp.EType, wr, rhs.Tok));
            foreach (Expression dim in tp.ArrayDimensions) {
              wr.Write(", ");
              TrParenExpr(dim, wr, false);
            }
            wr.Write(")");
          } else {
            wr.Write("new {0}", TypeName(tp.EType, wr, rhs.Tok));
            string prefix = "[";
            foreach (Expression dim in tp.ArrayDimensions) {
              wr.Write("{0}(int)", prefix);
              TrParenExpr(dim, wr, false);
              prefix = ", ";
            }
            wr.Write("]");
          }
        }
      }
    }

    void TrStmtList(List<Statement/*!*/>/*!*/ stmts, int indent, TextWriter writer) {
      Contract.Requires(cce.NonNullElements(stmts));
      foreach (Statement ss in stmts) {
        copyInstrWriters.Push(new StringBuilder());
        TextWriter wr = TrStmt(ss, indent + IndentAmount);
        // write out any copy instructions that copies the out param
        // used in letexpr to a local
        string copyInstr = copyInstrWriters.Pop().ToString();
        if (copyInstr != "") {
          Indent(indent + IndentAmount, writer);
          writer.Write(copyInstr);
        }
        writer.Write(wr.ToString());
        if (ss.Labels != null) {
          Indent(indent, writer);  // labels are not indented as much as the statements
          writer.WriteLine("after_{0}: ;", ss.Labels.Data.AssignUniqueId("after_", idGenerator));
        }
      }
    }

    void TrLocalVar(IVariable v, bool alwaysInitialize, int indent, TextWriter wr) {
      Contract.Requires(v != null);
      if (v.IsGhost) {
        // only emit non-ghosts (we get here only for local variables introduced implicitly by call statements)
        return;
      }

      Indent(indent, wr);
      wr.Write("{0} @{1}", TypeName(v.Type, wr, v.Tok), v.CompileName);
      if (alwaysInitialize) {
        // produce a default value
        wr.WriteLine(" = {0};", DefaultValue(v.Type, wr, v.Tok));
      } else {
        wr.WriteLine(";");
      }
    }

    void MatchCasePrelude(string source, UserDefinedType sourceType, DatatypeCtor ctor, List<BoundVar/*!*/>/*!*/ arguments, int caseIndex, int caseCount, int indent, TextWriter wr) {
      Contract.Requires(source != null);
      Contract.Requires(sourceType != null);
      Contract.Requires(ctor != null);
      Contract.Requires(cce.NonNullElements(arguments));
      Contract.Requires(0 <= indent);
      // if (source.is_Ctor0) {
      //   FormalType f0 = ((Dt_Ctor0)source._D).a0;
      //   ...
      Indent(indent, wr);
      wr.Write("{0}if (", caseIndex == 0 ? "" : "} else ");
      if (caseIndex == caseCount - 1) {
        wr.Write("true");
      } else {
        wr.Write("{0}.is_{1}", source, ctor.CompileName);
      }
      wr.WriteLine(") {");

      int k = 0;  // number of processed non-ghost arguments
      for (int m = 0; m < ctor.Formals.Count; m++) {
        Formal arg = ctor.Formals[m];
        if (!arg.IsGhost) {
          BoundVar bv = arguments[m];
          // FormalType f0 = ((Dt_Ctor0)source._D).a0;
          Indent(indent + IndentAmount, wr);
          wr.WriteLine("{0} @{1} = (({2}){3}._D).@{4};",
            TypeName(bv.Type, wr, bv.Tok), bv.CompileName, DtCtorName(ctor, sourceType.TypeArgs, wr), source, FormalName(arg, k));
          k++;
        }
      }
    }

    // ----- Expression ---------------------------------------------------------------------------

    /// <summary>
    /// Before calling TrParenExpr(expr), the caller must have spilled the let variables declared in "expr".
    /// </summary>
    void TrParenExpr(string prefix, Expression expr, TextWriter wr, bool inLetExprBody) {
      Contract.Requires(prefix != null);
      Contract.Requires(expr != null);
      wr.Write(prefix);
      TrParenExpr(expr, wr, inLetExprBody);
    }

    /// <summary>
    /// Before calling TrParenExpr(expr), the caller must have spilled the let variables declared in "expr".
    /// </summary>
    void TrParenExpr(Expression expr, TextWriter wr, bool inLetExprBody) {
      Contract.Requires(expr != null);
      wr.Write("(");
      TrExpr(expr, wr, inLetExprBody);
      wr.Write(")");
    }

    /// <summary>
    /// Before calling TrExprList(exprs), the caller must have spilled the let variables declared in expressions in "exprs".
    /// </summary>
    void TrExprList(List<Expression/*!*/>/*!*/ exprs, TextWriter wr, bool inLetExprBody) {
      Contract.Requires(cce.NonNullElements(exprs));
      wr.Write("(");
      string sep = "";
      foreach (Expression e in exprs) {
        wr.Write(sep);
        TrExpr(e, wr, inLetExprBody);
        sep = ", ";
      }
      wr.Write(")");
    }
    void TrExprPairList(List<ExpressionPair/*!*/>/*!*/ exprs, TextWriter wr, bool inLetExprBody) {
      Contract.Requires(cce.NonNullElements(exprs));
      wr.Write("(");
      string sep = "";
      foreach (ExpressionPair p in exprs) {
        wr.Write(sep);
        wr.Write("new Dafny.Pair<");
        wr.Write(TypeName(p.A.Type, wr, p.A.tok));
        wr.Write(",");
        wr.Write(TypeName(p.B.Type, wr, p.B.tok));
        wr.Write(">(");
        TrExpr(p.A, wr, inLetExprBody);
        wr.Write(",");
        TrExpr(p.B, wr, inLetExprBody);
        wr.Write(")");
        sep = ", ";
      }
      wr.Write(")");
    }

    /// <summary>
    /// Before calling TrExpr(expr), the caller must have spilled the let variables declared in "expr".
    /// </summary>
    void TrExpr(Expression expr, TextWriter wr, bool inLetExprBody) {
      Contract.Requires(expr != null);
      if (expr is LiteralExpr) {
        LiteralExpr e = (LiteralExpr)expr;
        if (e is StaticReceiverExpr) {
          wr.Write(TypeName(e.Type, wr, e.tok));
        } else if (e.Value == null) {
          wr.Write("({0})null", TypeName(e.Type, wr, e.tok));
        } else if (e.Value is bool) {
          wr.Write((bool)e.Value ? "true" : "false");
        } else if (e is CharLiteralExpr) {
          wr.Write("'{0}'", (string)e.Value);
        } else if (e is StringLiteralExpr) {
          var str = (StringLiteralExpr)e;
          wr.Write("{0}<char>.FromString({1}\"{2}\")", DafnySeqClass, str.IsVerbatim ? "@" : "", (string)e.Value);
        } else if (AsNativeType(e.Type) != null) {
          wr.Write((BigInteger)e.Value + AsNativeType(e.Type).Suffix);
        } else if (e.Value is BigInteger) {
          BigInteger i = (BigInteger)e.Value;
          if (new BigInteger(int.MinValue) <= i && i <= new BigInteger(int.MaxValue)) {
            wr.Write("new BigInteger({0})", i);
          } else {
            wr.Write("BigInteger.Parse(\"{0}\")", i);
          }
        } else if (e.Value is Basetypes.BigDec) {
          var n = (Basetypes.BigDec)e.Value;
          if (0 <= n.Exponent) {
            wr.Write("new Dafny.BigRational(new BigInteger({0}", n.Mantissa);
            for (int i = 0; i < n.Exponent; i++) {
              wr.Write("0");
            }
            wr.Write("), BigInteger.One)");
          } else {
            wr.Write("new Dafny.BigRational(new BigInteger({0}), new BigInteger(1", n.Mantissa);
            for (int i = n.Exponent; i < 0; i++) {
              wr.Write("0");
            }
            wr.Write("))");
          }
        } else {
          Contract.Assert(false); throw new cce.UnreachableException();  // unexpected literal
        }

      } else if (expr is ThisExpr) {
        wr.Write(enclosingMethod != null && enclosingMethod.IsTailRecursive ? "_this" : "this");

      } else if (expr is IdentifierExpr) {
        var e = (IdentifierExpr)expr;
        if (e.Var is Formal && inLetExprBody && !((Formal)e.Var).InParam) {
          // out param in letExpr body, need to copy it to a temp since
          // letExpr body is translated to an anonymous function that doesn't
          // allow out parameters
          var name = string.Format("_pat_let_tv{0}", GetUniqueAstNumber(e));
          wr.Write("@" + name);
          copyInstrWriters.Peek().Append("var @" + name + "= @" + e.Var.CompileName + ";\n");
        } else {
          wr.Write("@" + e.Var.CompileName);
        }
      } else if (expr is SetDisplayExpr) {
        var e = (SetDisplayExpr)expr;
        var elType = e.Type.AsSetType.Arg;
        wr.Write("{0}<{1}>.FromElements", DafnySetClass, TypeName(elType, wr, e.tok));
        TrExprList(e.Elements, wr, inLetExprBody);

      } else if (expr is MultiSetDisplayExpr) {
        var e = (MultiSetDisplayExpr)expr;
        var elType = e.Type.AsMultiSetType.Arg;
        wr.Write("{0}<{1}>.FromElements", DafnyMultiSetClass, TypeName(elType, wr, e.tok));
        TrExprList(e.Elements, wr, inLetExprBody);

      } else if (expr is SeqDisplayExpr) {
        var e = (SeqDisplayExpr)expr;
        var elType = e.Type.AsSeqType.Arg;
        wr.Write("{0}<{1}>.FromElements", DafnySeqClass, TypeName(elType, wr, e.tok));
        TrExprList(e.Elements, wr, inLetExprBody);

      } else if (expr is MapDisplayExpr) {
        MapDisplayExpr e = (MapDisplayExpr)expr;
        wr.Write("{0}.FromElements", TypeName(e.Type, wr, e.tok));
        TrExprPairList(e.Elements, wr, inLetExprBody);

      } else if (expr is MemberSelectExpr) {
        MemberSelectExpr e = (MemberSelectExpr)expr;
        SpecialField sf = e.Member as SpecialField;
        if (sf != null) {
          wr.Write(sf.PreString);
          if (sf.IsStatic) {
            wr.Write(TypeName_Companion(e.Obj.Type, wr, e.tok));
          } else {
            TrParenExpr(e.Obj, wr, inLetExprBody);
          }
          if (sf.CompiledName.Length != 0) {
            wr.Write(".@{0}", sf.CompiledName);
          }
          if (sf is ConstantField) {
            wr.Write("()");  // constant fields are compiled as functions (possibly with a backing field)
          }
          wr.Write(sf.PostString);
        } else {
          TrExpr(e.Obj, wr, inLetExprBody);
          wr.Write(".@{0}", e.Member.CompileName);
        }

      } else if (expr is SeqSelectExpr) {
        SeqSelectExpr e = (SeqSelectExpr)expr;
        Contract.Assert(e.Seq.Type != null);
        if (e.Seq.Type.IsArrayType) {
          if (e.SelectOne) {
            Contract.Assert(e.E0 != null && e.E1 == null);
            TrParenExpr(e.Seq, wr, inLetExprBody);
            wr.Write("[(int)");
            TrParenExpr(e.E0, wr, inLetExprBody);
            wr.Write("]");
          } else {
            TrParenExpr("Dafny.Helpers.SeqFromArray", e.Seq, wr, inLetExprBody);
            if (e.E1 != null) {
              TrParenExpr(".Take", e.E1, wr, inLetExprBody);
            }
            if (e.E0 != null) {
              TrParenExpr(".Drop", e.E0, wr, inLetExprBody);
            }
          }
        } else if (e.SelectOne) {
          Contract.Assert(e.E0 != null && e.E1 == null);
          TrParenExpr(e.Seq, wr, inLetExprBody);
          TrParenExpr(".Select", e.E0, wr, inLetExprBody);
        } else {
          TrParenExpr(e.Seq, wr, inLetExprBody);
          if (e.E1 != null) {
            TrParenExpr(".Take", e.E1, wr, inLetExprBody);
          }
          if (e.E0 != null) {
            TrParenExpr(".Drop", e.E0, wr, inLetExprBody);
          }
        }
      } else if (expr is MultiSetFormingExpr) {
        var e = (MultiSetFormingExpr)expr;
        wr.Write("{0}<{1}>", DafnyMultiSetClass, TypeName(e.E.Type.AsCollectionType.Arg, wr, e.tok));
        var eeType = e.E.Type.NormalizeExpand();
        if (eeType is SeqType) {
          TrParenExpr(".FromSeq", e.E, wr, inLetExprBody);
        } else if (eeType is SetType) {
          TrParenExpr(".FromSet", e.E, wr, inLetExprBody);
        } else {
          Contract.Assert(false); throw new cce.UnreachableException();
        }
      } else if (expr is MultiSelectExpr) {
        MultiSelectExpr e = (MultiSelectExpr)expr;
        TrParenExpr(e.Array, wr, inLetExprBody);
        string prefix = "[";
        foreach (Expression idx in e.Indices) {
          wr.Write("{0}(int)", prefix);
          TrParenExpr(idx, wr, inLetExprBody);
          prefix = ", ";
        }
        wr.Write("]");

      } else if (expr is SeqUpdateExpr) {
        SeqUpdateExpr e = (SeqUpdateExpr)expr;
        if (e.ResolvedUpdateExpr != null) {
          TrExpr(e.ResolvedUpdateExpr, wr, inLetExprBody);
        } else {
          TrParenExpr(e.Seq, wr, inLetExprBody);
          wr.Write(".Update(");
          TrExpr(e.Index, wr, inLetExprBody);
          wr.Write(", ");
          TrExpr(e.Value, wr, inLetExprBody);
          wr.Write(")");
        }

      } else if (expr is FunctionCallExpr) {
        FunctionCallExpr e = (FunctionCallExpr)expr;
        if (e.Function is SpecialFunction) {
          CompileSpecialFunctionCallExpr(e, wr, inLetExprBody, TrExpr);
        } else {
          CompileFunctionCallExpr(e, wr, wr, inLetExprBody, TrExpr);
        }

      } else if (expr is ApplyExpr) {
        var e = expr as ApplyExpr;
        wr.Write("Dafny.Helpers.Id<");
        wr.Write(TypeName(e.Function.Type, wr, e.tok));
        wr.Write(">(");
        TrExpr(e.Function, wr, inLetExprBody);
        wr.Write(")");
        TrExprList(e.Args, wr, inLetExprBody);

      } else if (expr is DatatypeValue) {
        DatatypeValue dtv = (DatatypeValue)expr;
        Contract.Assert(dtv.Ctor != null);  // since dtv has been successfully resolved
        var typeParams = dtv.InferredTypeArgs.Count == 0 ? "" : string.Format("<{0}>", TypeNames(dtv.InferredTypeArgs, wr, dtv.tok));
        wr.Write("new @{0}{1}(", DtName(dtv.Ctor.EnclosingDatatype), typeParams);
        if (!dtv.IsCoCall) {
          // For an ordinary constructor (that is, one that does not guard any co-recursive calls), generate:
          //   new Dt_Cons<T>( args )
          wr.Write("new {0}(", DtCtorName(dtv.Ctor, dtv.InferredTypeArgs, wr));
          string sep = "";
          for (int i = 0; i < dtv.Arguments.Count; i++) {
            Formal formal = dtv.Ctor.Formals[i];
            if (!formal.IsGhost) {
              wr.Write(sep);
              TrExpr(dtv.Arguments[i], wr, inLetExprBody);
              sep = ", ";
            }
          }
          wr.Write(")");
        } else {
          // In the case of a co-recursive call, generate:
          //     new Dt__Lazy<T>( LAMBDA )
          // where LAMBDA is:
          //     () => { return Dt_Cons<T>( ...args... ); }
          wr.Write("new {0}__Lazy{1}(", dtv.DatatypeName, typeParams);

          wr.Write("() => {{ return new {0}(", DtCtorName(dtv.Ctor, dtv.InferredTypeArgs, wr));
          string sep = "";
          for (int i = 0; i < dtv.Arguments.Count; i++) {
            Formal formal = dtv.Ctor.Formals[i];
            if (!formal.IsGhost) {
              wr.Write(sep);
              TrExpr(dtv.Arguments[i], wr, inLetExprBody);
              sep = ", ";
            }
          }
          wr.Write("); })");
        }
        wr.Write(")");

      } else if (expr is OldExpr) {
        Contract.Assert(false); throw new cce.UnreachableException();  // 'old' is always a ghost (right?)

      } else if (expr is UnaryOpExpr) {
        var e = (UnaryOpExpr)expr;
        switch (e.Op) {
          case UnaryOpExpr.Opcode.Not:
            if (e.Type.IsBitVectorType) {
              var bvType = (BitvectorType)e.Type;
              BitvectorTruncation(bvType, wr, false, false);
              wr.Write("~");
              TrParenExpr(e.E, wr, inLetExprBody);
              BitvectorTruncation(bvType, wr, true, false);

            } else {
              // Piece o' cake! This is just simple boolean negation.
              wr.Write("!");
              TrParenExpr(e.E, wr, inLetExprBody);
            }
            break;
          case UnaryOpExpr.Opcode.Cardinality:
            wr.Write("new BigInteger(");
            TrParenExpr(e.E, wr, inLetExprBody);
            wr.Write(".Length)");
            break;
          default:
            Contract.Assert(false); throw new cce.UnreachableException();  // unexpected unary expression
        }

      } else if (expr is ConversionExpr) {
        var e = (ConversionExpr)expr;
        if (e.E.Type.IsNumericBased(Type.NumericPersuation.Int) || e.E.Type.IsBitVectorType || e.E.Type.IsCharType) {
          if (e.ToType.IsNumericBased(Type.NumericPersuation.Real)) {
            // (int or bv) -> real
            Contract.Assert(AsNativeType(e.ToType) == null);
            wr.Write("new Dafny.BigRational(");
            if (AsNativeType(e.E.Type) != null) {
              wr.Write("new BigInteger");
            }
            TrParenExpr(e.E, wr, inLetExprBody);
            wr.Write(", BigInteger.One)");
          } else if (e.ToType.IsCharType) {
            wr.Write("(char)(");
            TrExpr(e.E, wr, inLetExprBody);
            wr.Write(")");
          } else {
            // (int or bv) -> (int or bv or ORDINAL)
            var fromNative = AsNativeType(e.E.Type);
            var toNative = AsNativeType(e.ToType);
            if (fromNative == null && toNative == null) {
              // big-integer (int or bv) -> big-integer (int or bv or ORDINAL), so identity will do
              TrExpr(e.E, wr, inLetExprBody);
            } else if (fromNative != null && toNative == null) {
              // native (int or bv) -> big-integer (int or bv)
              wr.Write("new BigInteger");
              TrParenExpr(e.E, wr, inLetExprBody);
            } else {
              // any (int or bv) -> native (int or bv)
              // A cast would do, but we also consider some optimizations
              wr.Write("({0})", toNative.Name);

              var literal = PartiallyEvaluate(e.E);
              UnaryOpExpr u = e.E.Resolved as UnaryOpExpr;
              MemberSelectExpr m = e.E.Resolved as MemberSelectExpr;
              if (literal != null) {
                // Optimize constant to avoid intermediate BigInteger
                wr.Write("(" + literal + toNative.Suffix + ")");
              } else if ((u != null && u.Op == UnaryOpExpr.Opcode.Cardinality) || (m != null && m.MemberName == "Length" && m.Obj.Type.IsArrayType)) {
                // Optimize .Length to avoid intermediate BigInteger
                TrParenExpr((u != null) ? u.E : m.Obj, wr, inLetExprBody);
                if (toNative.UpperBound <= new BigInteger(0x80000000U)) {
                  wr.Write(".Length");
                } else {
                  wr.Write(".LongLength");
                }
              } else {
                // no optimization applies; use the standard translation
                TrParenExpr(e.E, wr, inLetExprBody);
              }

            }
          }
        } else if (e.E.Type.IsNumericBased(Type.NumericPersuation.Real)) {
          Contract.Assert(AsNativeType(e.E.Type) == null);
          if (e.ToType.IsNumericBased(Type.NumericPersuation.Real)) {
            // real -> real
            Contract.Assert(AsNativeType(e.ToType) == null);
            TrExpr(e.E, wr, inLetExprBody);
          } else {
            // real -> (int or bv)
            if (AsNativeType(e.ToType) != null) {
              wr.Write("({0})", AsNativeType(e.ToType).Name);
            }
            TrParenExpr(e.E, wr, inLetExprBody);
            wr.Write(".ToBigInteger()");
          }
        } else {
          Contract.Assert(e.E.Type.IsBigOrdinalType);
          Contract.Assert(e.ToType.IsNumericBased(Type.NumericPersuation.Int));
          // identity will do
          TrExpr(e.E, wr, inLetExprBody);
        }

      } else if (expr is BinaryExpr) {
        BinaryExpr e = (BinaryExpr)expr;
        string opString = null;
        string preOpString = "";
        string callString = null;
        string staticCallString = null;
        bool reverseArguments = false;
        bool truncateResult = false;
        bool convertE1_to_int = false;

        switch (e.ResolvedOp) {
          case BinaryExpr.ResolvedOpcode.Iff:
            opString = "=="; break;
          case BinaryExpr.ResolvedOpcode.Imp:
            preOpString = "!"; opString = "||"; break;
          case BinaryExpr.ResolvedOpcode.Or:
            opString = "||"; break;
          case BinaryExpr.ResolvedOpcode.And:
            opString = "&&"; break;
          case BinaryExpr.ResolvedOpcode.BitwiseAnd:
            opString = "&"; break;
          case BinaryExpr.ResolvedOpcode.BitwiseOr:
            opString = "|"; break;
          case BinaryExpr.ResolvedOpcode.BitwiseXor:
            opString = "^"; break;

          case BinaryExpr.ResolvedOpcode.EqCommon: {
              if (e.E0.Type.IsRefType) {
                // Dafny's type rules are slightly different C#, so we may need a cast here.
                // For example, Dafny allows x==y if x:array<T> and y:array<int> and T is some
                // type parameter.
                opString = "== (object)";
              } else if (e.E0.Type.IsDatatype || e.E0.Type.IsTypeParameter || e.E0.Type.SupportsEquality) {
                callString = "Equals";
              } else {
                opString = "==";
              }
              break;
            }
          case BinaryExpr.ResolvedOpcode.NeqCommon: {
              if (e.E0.Type.IsRefType) {
                // Dafny's type rules are slightly different C#, so we may need a cast here.
                // For example, Dafny allows x==y if x:array<T> and y:array<int> and T is some
                // type parameter.
                opString = "!= (object)";
              } else if (e.E0.Type.IsDatatype || e.E0.Type.IsTypeParameter || e.E0.Type.SupportsEquality) {
                preOpString = "!";
                callString = "Equals";
              } else {
                opString = "!=";
              }
              break;
            }

          case BinaryExpr.ResolvedOpcode.Lt:
          case BinaryExpr.ResolvedOpcode.LtChar:
            opString = "<"; break;
          case BinaryExpr.ResolvedOpcode.Le:
          case BinaryExpr.ResolvedOpcode.LeChar:
            opString = "<="; break;
          case BinaryExpr.ResolvedOpcode.Ge:
          case BinaryExpr.ResolvedOpcode.GeChar:
            opString = ">="; break;
          case BinaryExpr.ResolvedOpcode.Gt:
          case BinaryExpr.ResolvedOpcode.GtChar:
            opString = ">"; break;
          case BinaryExpr.ResolvedOpcode.LeftShift:
            opString = "<<"; truncateResult = true; convertE1_to_int = true; break;
          case BinaryExpr.ResolvedOpcode.RightShift:
            opString = ">>"; convertE1_to_int = true; break;
          case BinaryExpr.ResolvedOpcode.Add:
            opString = "+"; truncateResult = true; break;
          case BinaryExpr.ResolvedOpcode.Sub:
            opString = "-"; truncateResult = true; break;
          case BinaryExpr.ResolvedOpcode.Mul:
            opString = "*"; truncateResult = true; break;
          case BinaryExpr.ResolvedOpcode.Div:
            if (expr.Type.IsIntegerType || (AsNativeType(expr.Type) != null && AsNativeType(expr.Type).LowerBound < BigInteger.Zero)) {
              var suffix = AsNativeType(expr.Type) != null ? "_" + AsNativeType(expr.Type).Name : "";
              staticCallString = "Dafny.Helpers.EuclideanDivision" + suffix;
            } else {
              opString = "/";  // for reals
            }
            break;
          case BinaryExpr.ResolvedOpcode.Mod:
            if (expr.Type.IsIntegerType || (AsNativeType(expr.Type) != null && AsNativeType(expr.Type).LowerBound < BigInteger.Zero)) {
              var suffix = AsNativeType(expr.Type) != null ? "_" + AsNativeType(expr.Type).Name : "";
              staticCallString = "Dafny.Helpers.EuclideanModulus" + suffix;
            } else {
              opString = "%";  // for reals
            }
            break;
          case BinaryExpr.ResolvedOpcode.SetEq:
          case BinaryExpr.ResolvedOpcode.MultiSetEq:
          case BinaryExpr.ResolvedOpcode.SeqEq:
          case BinaryExpr.ResolvedOpcode.MapEq:
            callString = "Equals"; break;
          case BinaryExpr.ResolvedOpcode.SetNeq:
          case BinaryExpr.ResolvedOpcode.MultiSetNeq:
          case BinaryExpr.ResolvedOpcode.SeqNeq:
          case BinaryExpr.ResolvedOpcode.MapNeq:
            preOpString = "!"; callString = "Equals"; break;
          case BinaryExpr.ResolvedOpcode.ProperSubset:
          case BinaryExpr.ResolvedOpcode.ProperMultiSubset:
            callString = "IsProperSubsetOf"; break;
          case BinaryExpr.ResolvedOpcode.Subset:
          case BinaryExpr.ResolvedOpcode.MultiSubset:
            callString = "IsSubsetOf"; break;
          case BinaryExpr.ResolvedOpcode.Superset:
          case BinaryExpr.ResolvedOpcode.MultiSuperset:
            callString = "IsSupersetOf"; break;
          case BinaryExpr.ResolvedOpcode.ProperSuperset:
          case BinaryExpr.ResolvedOpcode.ProperMultiSuperset:
            callString = "IsProperSupersetOf"; break;
          case BinaryExpr.ResolvedOpcode.Disjoint:
          case BinaryExpr.ResolvedOpcode.MultiSetDisjoint:
          case BinaryExpr.ResolvedOpcode.MapDisjoint:
            callString = "IsDisjointFrom"; break;
          case BinaryExpr.ResolvedOpcode.InSet:
          case BinaryExpr.ResolvedOpcode.InMultiSet:
          case BinaryExpr.ResolvedOpcode.InMap:
            callString = "Contains"; reverseArguments = true; break;
          case BinaryExpr.ResolvedOpcode.NotInSet:
          case BinaryExpr.ResolvedOpcode.NotInMultiSet:
          case BinaryExpr.ResolvedOpcode.NotInMap:
            preOpString = "!"; callString = "Contains"; reverseArguments = true; break;
          case BinaryExpr.ResolvedOpcode.Union:
          case BinaryExpr.ResolvedOpcode.MultiSetUnion:
            callString = "Union"; break;
          case BinaryExpr.ResolvedOpcode.Intersection:
          case BinaryExpr.ResolvedOpcode.MultiSetIntersection:
            callString = "Intersect"; break;
          case BinaryExpr.ResolvedOpcode.SetDifference:
          case BinaryExpr.ResolvedOpcode.MultiSetDifference:
            callString = "Difference"; break;

          case BinaryExpr.ResolvedOpcode.ProperPrefix:
            callString = "IsProperPrefixOf"; break;
          case BinaryExpr.ResolvedOpcode.Prefix:
            callString = "IsPrefixOf"; break;
          case BinaryExpr.ResolvedOpcode.Concat:
            callString = "Concat"; break;
          case BinaryExpr.ResolvedOpcode.InSeq:
            callString = "Contains"; reverseArguments = true; break;
          case BinaryExpr.ResolvedOpcode.NotInSeq:
            preOpString = "!"; callString = "Contains"; reverseArguments = true; break;

          default:
            Contract.Assert(false); throw new cce.UnreachableException();  // unexpected binary expression
        }

        if (truncateResult && e.Type.IsBitVectorType) {
          BitvectorTruncation((BitvectorType)e.Type, wr, false, true);
        }
        var e0 = reverseArguments ? e.E1 : e.E0;
        var e1 = reverseArguments ? e.E0 : e.E1;
        if (opString != null) {
          NativeType nativeType = AsNativeType(e.Type);
          bool needsCast = nativeType != null && nativeType.NeedsCastAfterArithmetic;
          if (needsCast) {
            wr.Write("(" + nativeType.Name + ")(");
          }
          wr.Write(preOpString);
          TrParenExpr(e0, wr, inLetExprBody);
          wr.Write(" {0} ", opString);
          if (convertE1_to_int) {
            wr.Write("(int)");
          }
          TrParenExpr(e1, wr, inLetExprBody);
          if (needsCast) {
            wr.Write(")");
          }
        } else if (callString != null) {
          wr.Write(preOpString);
          TrParenExpr(e0, wr, inLetExprBody);
          wr.Write(".@{0}(", callString);
          TrExpr(e1, wr, inLetExprBody);
          wr.Write(")");
        } else if (staticCallString != null) {
          wr.Write(preOpString);
          wr.Write("{0}(", staticCallString);
          TrExpr(e0, wr, inLetExprBody);
          wr.Write(", ");
          TrExpr(e1, wr, inLetExprBody);
          wr.Write(")");
        }
        if (truncateResult && e.Type.IsBitVectorType) {
          BitvectorTruncation((BitvectorType)e.Type, wr, true, true);
        }

      } else if (expr is TernaryExpr) {
        Contract.Assume(false);  // currently, none of the ternary expressions is compilable

      } else if (expr is LetExpr) {
        var e = (LetExpr)expr;
        if (e.Exact) {
          // The Dafny "let" expression
          //    var Pattern(x,y) := G; E
          // is translated into C# as:
          //    LamLet(G, tmp =>
          //      LamLet(dtorX(tmp), x =>
          //      LamLet(dtorY(tmp), y => E)))
          Contract.Assert(e.LHSs.Count == e.RHSs.Count);  // checked by resolution
          var neededCloseParens = 0;
          for (int i = 0; i < e.LHSs.Count; i++) {
            var lhs = e.LHSs[i];
            if (Contract.Exists(lhs.Vars, bv => !bv.IsGhost)) {
              var rhsName = string.Format("_pat_let{0}_{1}", GetUniqueAstNumber(e), i);
              wr.Write("Dafny.Helpers.Let<");
              wr.Write(TypeName(e.RHSs[i].Type, wr, e.RHSs[i].tok) + "," + TypeName(e.Body.Type, wr, e.Body.tok));
              wr.Write(">(");
              TrExpr(e.RHSs[i], wr, inLetExprBody);
              wr.Write(", " + rhsName + " => ");
              neededCloseParens++;
              var c = TrCasePattern(lhs, rhsName, e.Body.Type, wr);
              Contract.Assert(c != 0);  // we already checked that there's at least one non-ghost
              neededCloseParens += c;
            }
          }

          TrExpr(e.Body, wr, true);
          for (int i = 0; i < neededCloseParens; i++) {
            wr.Write(")");
          }
        } else if (e.BoundVars.All(bv => bv.IsGhost)) {
          // The Dafny "let" expression
          //    ghost var x,y :| Constraint; E
          // is compiled just like E is, because the resolver has already checked that x,y (or other ghost variables, for that matter) don't
          // occur in E (moreover, the verifier has checked that values for x,y satisfying Constraint exist).
          TrExpr(e.Body, wr, inLetExprBody);
        } else {
          // The Dafny "let" expression
          //    var x,y :| Constraint; E
          // is translated into C# as:
          //    LamLet(0, dummy => {  // the only purpose of this construction here is to allow us to add some code inside an expression in C#
          //        var x,y;
          //        // Embark on computation that fills in x,y according to Constraint; the computation stops when the first
          //        // such value is found, but since the verifier checks that x,y follows uniquely from Constraint, this is
          //        // not a source of nondeterminancy.
          //        return E;
          //      })
          Contract.Assert(e.RHSs.Count == 1);  // checked by resolution
          if (e.Constraint_MissingBounds != null) {
            foreach (var bv in e.Constraint_MissingBounds) {
              Error(e.tok, "this let-such-that expression is too advanced for the current compiler; Dafny's heuristics cannot find any bound for variable '{0}'", wr, bv.Name);
            }
          } else {
            wr.Write("Dafny.Helpers.Let<int," + TypeName(e.Body.Type, wr, e.Body.tok) + ">(0, _let_dummy_" + GetUniqueAstNumber(e) + " => {");
            foreach (var bv in e.BoundVars) {
              wr.Write("{0} @{1}", TypeName(bv.Type, wr, bv.tok), bv.CompileName);
              wr.WriteLine(" = {0};", DefaultValue(bv.Type, wr, bv.tok));
            }
            TrAssignSuchThat(0, new List<IVariable>(e.BoundVars).ConvertAll(bv => (IVariable)bv), e.RHSs[0], e.Constraint_Bounds, e.tok.line, wr, inLetExprBody);
            wr.Write(" return ");
            TrExpr(e.Body, wr, true);
            wr.Write("; })");
          }
        }

      } else if (expr is MatchExpr) {
        var e = (MatchExpr)expr;
        // new Dafny.Helpers.Function<SourceType, TargetType>(delegate (SourceType _source) {
        //   if (source.is_Ctor0) {
        //     FormalType f0 = ((Dt_Ctor0)source._D).a0;
        //     ...
        //     return Body0;
        //   } else if (...) {
        //     ...
        //   } else if (true) {
        //     ...
        //   }
        // }(src)

        string source = idGenerator.FreshId("_source");
        wr.Write("new Dafny.Helpers.Function<{0}, {1}>(delegate ({0} {2}) {{ ", TypeName(e.Source.Type, wr, e.tok), TypeName(e.Type, wr, e.tok), source);

        if (e.Cases.Count == 0) {
          // the verifier would have proved we never get here; still, we need some code that will compile
          wr.Write("throw new System.Exception();");
        } else {
          int i = 0;
          var sourceType = (UserDefinedType)e.Source.Type.NormalizeExpand();
          foreach (MatchCaseExpr mc in e.Cases) {
            MatchCasePrelude(source, sourceType, cce.NonNull(mc.Ctor), mc.Arguments, i, e.Cases.Count, 0, wr);
            wr.Write("return ");
            TrExpr(mc.Body, wr, inLetExprBody);
            wr.Write("; ");
            i++;
          }
          wr.Write("}");
        }
        // We end with applying the source expression to the delegate we just built
        wr.Write("})(");
        TrExpr(e.Source, wr, inLetExprBody);
        wr.Write(")");

      } else if (expr is QuantifierExpr) {
        var e = (QuantifierExpr)expr;

        // Compilation does not check whether a quantifier was split.

        Contract.Assert(e.Bounds != null);  // for non-ghost quantifiers, the resolver would have insisted on finding bounds
        var n = e.BoundVars.Count;
        Contract.Assert(e.Bounds.Count == n);
        for (int i = 0; i < n; i++) {
          var bound = e.Bounds[i];
          var bv = e.BoundVars[i];
          // emit:  Dafny.Helpers.QuantX(boundsInformation, isForall, bv => body)
          if (bound is ComprehensionExpr.BoolBoundedPool) {
            wr.Write("Dafny.Helpers.QuantBool(");
          } else if (bound is ComprehensionExpr.CharBoundedPool) {
            wr.Write("Dafny.Helpers.QuantChar(");
          } else if (bound is ComprehensionExpr.IntBoundedPool) {
            var b = (ComprehensionExpr.IntBoundedPool)bound;
            wr.Write("Dafny.Helpers.QuantInt(");
            var low = SubstituteBound(b, e.Bounds, e.BoundVars, i, true);
            TrExpr(low, wr, inLetExprBody);
            wr.Write(", ");
            var high = SubstituteBound(b, e.Bounds, e.BoundVars, i, false);
            TrExpr(high, wr, inLetExprBody);
            wr.Write(", ");
          } else if (bound is ComprehensionExpr.SetBoundedPool) {
            var b = (ComprehensionExpr.SetBoundedPool)bound;
            wr.Write("Dafny.Helpers.QuantSet(");
            TrExpr(b.Set, wr, inLetExprBody);
            wr.Write(", ");
          } else if (bound is ComprehensionExpr.MapBoundedPool) {
            var b = (ComprehensionExpr.MapBoundedPool)bound;
            wr.Write("Dafny.Helpers.QuantMap(");
            TrExpr(b.Map, wr, inLetExprBody);
            wr.Write(", ");
          } else if (bound is ComprehensionExpr.SeqBoundedPool) {
            var b = (ComprehensionExpr.SeqBoundedPool)bound;
            wr.Write("Dafny.Helpers.QuantSeq(");
            TrExpr(b.Seq, wr, inLetExprBody);
            wr.Write(", ");
          } else if (bound is ComprehensionExpr.DatatypeBoundedPool) {
            var b = (ComprehensionExpr.DatatypeBoundedPool)bound;
            wr.Write("Dafny.Helpers.QuantDatatype(");

            wr.Write("{0}.AllSingletonConstructors, ", DtName(b.Decl));
          } else {
            Contract.Assert(false); throw new cce.UnreachableException();  // unexpected BoundedPool type
          }
          wr.Write("{0}, ", expr is ForallExpr ? "true" : "false");
          var native = AsNativeType(e.BoundVars[i].Type);
          if (native != null) {
            wr.Write("Dafny.Helpers.PredicateConverter_{0}", native.Name);
          }
          wr.Write("(@{0} => ", bv.CompileName);
        }
        TrExpr(e.LogicalBody(true), wr, inLetExprBody);
        for (int i = 0; i < n; i++) {
          wr.Write("))");
        }

      } else if (expr is SetComprehension) {
        var e = (SetComprehension)expr;
        // For "set i,j,k,l | R(i,j,k,l) :: Term(i,j,k,l)" where the term has type "G", emit something like:
        // ((ComprehensionDelegate<G>)delegate() {
        //   var _coll = new List<G>();
        //   foreach (var tmp_l in sq.Elements) { L l = (L)tmp_l;
        //     foreach (var tmp_k in st.Elements) { K k = (K)tmp_k;
        //       for (BigInteger j = Lo; j < Hi; j++) {
        //         for (bool i in Helper.AllBooleans) {
        //           if (R(i,j,k,l)) {
        //             _coll.Add(Term(i,j,k,l));
        //           }
        //         }
        //       }
        //     }
        //   }
        //   return Dafny.Set<G>.FromCollection(_coll);
        // })()
        Contract.Assert(e.Bounds != null);  // the resolver would have insisted on finding bounds
        var typeName = TypeName(e.Type.AsSetType.Arg, wr, e.tok);
        var collection_name = idGenerator.FreshId("_coll");
        wr.Write("((Dafny.Helpers.ComprehensionDelegate<{0}>)delegate() {{ ", typeName);
        wr.Write("var {0} = new System.Collections.Generic.List<{1}>(); ", collection_name, typeName);
        var n = e.BoundVars.Count;
        Contract.Assert(e.Bounds.Count == n);
        for (int i = 0; i < n; i++) {
          var bound = e.Bounds[i];
          var bv = e.BoundVars[i];
          if (bound is ComprehensionExpr.BoolBoundedPool) {
            wr.Write("foreach (var @{0} in Dafny.Helpers.AllBooleans) {{ ", bv.CompileName);
          } else if (bound is ComprehensionExpr.CharBoundedPool) {
            wr.Write("foreach (var @{0} in Dafny.Helpers.AllChars) {{ ", bv.CompileName);
          } else if (bound is ComprehensionExpr.IntBoundedPool) {
            var b = (ComprehensionExpr.IntBoundedPool)bound;
            if (AsNativeType(bv.Type) != null) {
              wr.Write("foreach (var @{0} in @{1}.IntegerRange(", bv.CompileName, bv.Type.AsNewtype.FullCompileName);
            } else {
              wr.Write("foreach (var @{0} in Dafny.Helpers.IntegerRange(", bv.CompileName);
            }
            TrExpr(b.LowerBound, wr, inLetExprBody);
            wr.Write(", ");
            TrExpr(b.UpperBound, wr, inLetExprBody);
            wr.Write(")) { ");
          } else if (bound is ComprehensionExpr.SetBoundedPool) {
            var b = (ComprehensionExpr.SetBoundedPool)bound;
            var tmpVar = idGenerator.FreshId("_set_compr_");
            wr.Write("foreach (var @{0} in (", tmpVar);
            TrExpr(b.Set, wr, inLetExprBody);
            wr.Write(").Elements) {{ {0} @{1} = ({0}){2}; ", TypeName(bv.Type, wr, bv.tok), bv.CompileName, tmpVar);
          } else if (bound is ComprehensionExpr.MapBoundedPool) {
            var b = (ComprehensionExpr.MapBoundedPool)bound;
            var tmpVar = idGenerator.FreshId("_map_compr_");
            wr.Write("foreach (var @{0} in (", tmpVar);
            TrExpr(b.Map, wr, inLetExprBody);
            wr.Write(").Domain) {{ {0} @{1} = ({0}){2}; ", TypeName(bv.Type, wr, bv.tok), bv.CompileName, tmpVar);
          } else if (bound is ComprehensionExpr.SeqBoundedPool) {
            var b = (ComprehensionExpr.SeqBoundedPool)bound;
            var tmpVar = idGenerator.FreshId("_seq_compr_");
            wr.Write("foreach (var @{0} in (", tmpVar);
            TrExpr(b.Seq, wr, inLetExprBody);
            wr.Write(").Elements) { {0} @{1} = ({0}){2}; ", TypeName(bv.Type, wr, bv.tok), bv.CompileName, tmpVar);
          } else if (bound is ComprehensionExpr.DatatypeBoundedPool) {
            var b = (ComprehensionExpr.DatatypeBoundedPool)bound;
            wr.Write("foreach (var @{0} in {1}.AllSingletonConstructors) {{", bv.CompileName, TypeName(bv.Type, wr, bv.tok));
          } else {
            Contract.Assert(false); throw new cce.UnreachableException();  // unexpected BoundedPool type
          }
        }
        wr.Write("if (");
        TrExpr(e.Range, wr, inLetExprBody);
        wr.Write(") {");
        wr.Write("{0}.Add(", collection_name);
        TrExpr(e.Term, wr, inLetExprBody);
        wr.Write("); }");
        for (int i = 0; i < n; i++) {
          wr.Write("}");
        }
        wr.Write("return Dafny.Set<{0}>.FromCollection({1}); ", typeName, collection_name);
        wr.Write("})()");

      } else if (expr is MapComprehension) {
        var e = (MapComprehension)expr;
        // For "map i | R(i) :: Term(i)" where the term has type "V" and i has type "U", emit something like:
        // ((MapComprehensionDelegate<U, V>)delegate() {
        //   var _coll = new List<Pair<U,V>>();
        //   foreach (L l in sq.Elements) {
        //     foreach (K k in st.Elements) {
        //       for (BigInteger j = Lo; j < Hi; j++) {
        //         for (bool i in Helper.AllBooleans) {
        //           if (R(i,j,k,l)) {
        //             _coll.Add(new Pair(i, Term(i));
        //           }
        //         }
        //       }
        //     }
        //   }
        //   return Dafny.Map<U, V>.FromElements(_coll);
        // })()
        Contract.Assert(e.Bounds != null);  // the resolver would have insisted on finding bounds
        var domtypeName = TypeName(e.Type.AsMapType.Domain, wr, e.tok);
        var rantypeName = TypeName(e.Type.AsMapType.Range, wr, e.tok);
        var collection_name = idGenerator.FreshId("_coll");
        wr.Write("((Dafny.Helpers.MapComprehensionDelegate<{0},{1}>)delegate() {{ ", domtypeName, rantypeName);
        wr.Write("var {0} = new System.Collections.Generic.List<Dafny.Pair<{1},{2}>>(); ", collection_name, domtypeName, rantypeName);
        var n = e.BoundVars.Count;
        Contract.Assert(e.Bounds.Count == n && n == 1);
        var bound = e.Bounds[0];
        var bv = e.BoundVars[0];
        if (bound is ComprehensionExpr.BoolBoundedPool) {
          wr.Write("foreach (var @{0} in Dafny.Helpers.AllBooleans) {{ ", bv.CompileName);
        } else if (bound is ComprehensionExpr.CharBoundedPool) {
          wr.Write("foreach (var @{0} in Dafny.Helpers.AllChars) {{ ", bv.CompileName);
        } else if (bound is ComprehensionExpr.IntBoundedPool) {
          var b = (ComprehensionExpr.IntBoundedPool)bound;
          if (AsNativeType(bv.Type) != null) {
            wr.Write("foreach (var @{0} in @{1}.IntegerRange(", bv.CompileName, bv.Type.AsNewtype.FullCompileName);
          } else {
            wr.Write("foreach (var @{0} in Dafny.Helpers.IntegerRange(", bv.CompileName);
          }
          TrExpr(b.LowerBound, wr, inLetExprBody);
          wr.Write(", ");
          TrExpr(b.UpperBound, wr, inLetExprBody);
          wr.Write(")) { ");
        } else if (bound is ComprehensionExpr.SetBoundedPool) {
          var b = (ComprehensionExpr.SetBoundedPool)bound;
          wr.Write("foreach (var @{0} in (", bv.CompileName);
          TrExpr(b.Set, wr, inLetExprBody);
          wr.Write(").Elements) { ");
        } else if (bound is ComprehensionExpr.MapBoundedPool) {
          var b = (ComprehensionExpr.MapBoundedPool)bound;
          wr.Write("foreach (var @{0} in (", bv.CompileName);
          TrExpr(b.Map, wr, inLetExprBody);
          wr.Write(").Domain) { ");
        } else if (bound is ComprehensionExpr.SeqBoundedPool) {
          var b = (ComprehensionExpr.SeqBoundedPool)bound;
          wr.Write("foreach (var @{0} in (", bv.CompileName);
          TrExpr(b.Seq, wr, inLetExprBody);
          wr.Write(").Elements) { ");
        } else {
          // TODO: handle ComprehensionExpr.SubSetBoundedPool
          Contract.Assert(false); throw new cce.UnreachableException();  // unexpected BoundedPool type
        }
        wr.Write("if (");
        TrExpr(e.Range, wr, inLetExprBody);
        wr.Write(") { ");
        wr.Write("{0}.Add(new Dafny.Pair<{1},{2}>(@{3},", collection_name, domtypeName, rantypeName, bv.CompileName);
        TrExpr(e.Term, wr, inLetExprBody);
        wr.Write(")); }");
        wr.Write("}");
        wr.Write("return Dafny.Map<{0},{1}>.FromCollection({2}); ", domtypeName, rantypeName, collection_name);
        wr.Write("})()");

      } else if (expr is LambdaExpr) {
        LambdaExpr e = (LambdaExpr)expr;

        var fvs = Translator.ComputeFreeVariables(expr);
        var sm = new Dictionary<IVariable, Expression>();

        var bvars = new List<BoundVar>();
        var fexprs = new List<Expression>();
        foreach (var fv in fvs) {
          fexprs.Add(new IdentifierExpr(fv.Tok, fv.Name) {
            Var = fv, // resolved here!
            Type = fv.Type
          });
          var bv = new BoundVar(fv.Tok, fv.Name, fv.Type);
          bvars.Add(bv);
          sm[fv] = new IdentifierExpr(bv.Tok, bv.Name) {
            Var = bv, // resolved here!
            Type = bv.Type
          };
        }

        var su = new Translator.Substituter(null, sm, new Dictionary<TypeParameter, Type>());

        BetaRedex(bvars, fexprs, expr.Type, wr, inLetExprBody, () => {
          wr.Write("(");
          wr.Write(Util.Comma(e.BoundVars, bv => "@" + bv.CompileName));
          wr.Write(") => ");
          TrExpr(su.Substitute(e.Body), wr, inLetExprBody);
        });

      } else if (expr is StmtExpr) {
        var e = (StmtExpr)expr;
        TrExpr(e.E, wr, inLetExprBody);

      } else if (expr is ITEExpr) {
        ITEExpr e = (ITEExpr)expr;
        wr.Write("(");
        TrExpr(e.Test, wr, inLetExprBody);
        wr.Write(") ? (");
        TrExpr(e.Thn, wr, inLetExprBody);
        wr.Write(") : (");
        TrExpr(e.Els, wr, inLetExprBody);
        wr.Write(")");

      } else if (expr is ConcreteSyntaxExpression) {
        var e = (ConcreteSyntaxExpression)expr;
        TrExpr(e.ResolvedExpression, wr, inLetExprBody);

      } else if (expr is NamedExpr) {
        TrExpr(((NamedExpr)expr).Body, wr, inLetExprBody);
      } else {
        Contract.Assert(false); throw new cce.UnreachableException();  // unexpected expression
      }
    }

    private Expression SubstituteBound(ComprehensionExpr.IntBoundedPool b, List<ComprehensionExpr.BoundedPool> bounds, List<BoundVar> boundVars, int index, bool lowBound)
    {
      // if the outer bound is depended on the inner boundvar, we need to
      // substitute the inner boundvar with its bound.
      var low = lowBound ? b.LowerBound : b.UpperBound;
      var sm = new Dictionary<IVariable, Expression>();
      for (int i = index+1; i < boundVars.Count; i++) {
        var bound = bounds[i];
        if (bound is ComprehensionExpr.IntBoundedPool) {
          var ib = (ComprehensionExpr.IntBoundedPool)bound;
          var bv = boundVars[i];
          sm[bv] = lowBound ? ib.LowerBound : ib.UpperBound;
        }
      }
      var su = new Translator.Substituter(null, sm, new Dictionary<TypeParameter, Type>());
      return su.Substitute(low);
    }

    private static void BitvectorTruncation(BitvectorType bvType, TextWriter wr, bool after, bool surroundByUnchecked) {
      Contract.Requires(bvType != null);
      Contract.Requires(wr != null);
      if (!after) {
        if (bvType.NativeType == null) {
          wr.Write("((");
        } else {
          if (surroundByUnchecked) {
            // Unfortunately, the following will apply "unchecked" to all subexpressions as well.  There
            // shouldn't ever be any problem with this, but stylistically it would have been nice to have
            // applied the "unchecked" only to the actual operation that may overflow.
            wr.Write("unchecked(");
          }
          wr.Write("({0})((", bvType.NativeType.Name);
        }
      } else {
        // do the truncation, if needed
        if (bvType.NativeType == null) {
          wr.Write(") & ((new BigInteger(1) << {0}) - 1))", bvType.Width);
        } else {
          if (bvType.NativeType.Bitwidth != bvType.Width) {
            // print in hex, because that looks nice
            wr.Write(") & ({2})0x{0:X}{1})", (1UL << bvType.Width) - 1, bvType.NativeType.Suffix, bvType.NativeType.Name);
          } else {
            wr.Write("))");  // close the parentheses for the cast
          }
          if (surroundByUnchecked) {
            wr.Write(")");  // close the parentheses for the "unchecked"
          }
        }
      }
    }

    /// <summary>
    /// Try to evaluate "expr" into one BigInteger.  On success, return it; otherwise, return "null".
    /// </summary>
    /// <param name="expr"></param>
    /// <returns></returns>
    public static Nullable<BigInteger> PartiallyEvaluate(Expression expr) {
      Contract.Requires(expr != null);
      expr = expr.Resolved;
      if (expr is LiteralExpr) {
        var e = (LiteralExpr)expr;
        if (e.Value is BigInteger) {
          return (BigInteger)e.Value;
        }
      } else if (expr is BinaryExpr) {
        var e = (BinaryExpr)expr;
        switch (e.ResolvedOp) {
          case BinaryExpr.ResolvedOpcode.Add:
          case BinaryExpr.ResolvedOpcode.Sub:
          case BinaryExpr.ResolvedOpcode.Mul:
            // possibly the most important case is Sub, since that's how NegationExpression's end up
            var arg0 = PartiallyEvaluate(e.E0);
            var arg1 = arg0 == null ? null : PartiallyEvaluate(e.E1);
            if (arg1 != null) {
              switch (e.ResolvedOp) {
                case BinaryExpr.ResolvedOpcode.Add:
                  return arg0 + arg1;
                case BinaryExpr.ResolvedOpcode.Sub:
                  return arg0 - arg1;
                case BinaryExpr.ResolvedOpcode.Mul:
                  return arg0 * arg1;
                default:
                  Contract.Assert(false);
                  break;  // please compiler
              }
            }
            break;
          default:
            break;
        }
      }
      return null;
    }

    int TrCasePattern(CasePattern pat, string rhsString, Type bodyType, TextWriter wr) {
      Contract.Requires(pat != null);
      Contract.Requires(rhsString != null);
      int c = 0;
      if (pat.Var != null) {
        var bv = pat.Var;
        if (!bv.IsGhost) {
          wr.Write("Dafny.Helpers.Let<" + TypeName(bv.Type, wr, bv.tok) + "," + TypeName(bodyType, wr, pat.tok) + ">");
          wr.Write("(" + rhsString + ", @" + bv.CompileName + " => ");
          c++;
        }
      } else if (pat.Arguments != null) {
        var ctor = pat.Ctor;
        Contract.Assert(ctor != null);  // follows from successful resolution
        Contract.Assert(pat.Arguments.Count == ctor.Formals.Count);  // follows from successful resolution
        var k = 0;  // number of non-ghost formals processed
        for (int i = 0; i < pat.Arguments.Count; i++) {
          var arg = pat.Arguments[i];
          var formal = ctor.Formals[i];
          if (formal.IsGhost) {
            // nothing to compile, but do a sanity check
            Contract.Assert(!Contract.Exists(arg.Vars, bv => !bv.IsGhost));
          } else {
            c += TrCasePattern(arg, string.Format("(({0})({1})._D).@{2}", DtCtorName(ctor, ((DatatypeValue)pat.Expr).InferredTypeArgs, wr), rhsString, FormalName(formal, k)), bodyType, wr);
            k++;
          }
        }
      }
      return c;
    }

    delegate void FCE_Arg_Translator(Expression e, TextWriter wr, bool inLetExpr=false);

    void CompileSpecialFunctionCallExpr(FunctionCallExpr e, TextWriter wr, bool inLetExprBody, FCE_Arg_Translator tr) {
      string name = e.Function.Name;
      
      if (name == "RotateLeft") {
        CompileRotate(e.Receiver, e.Args[0], "<<", ">>", true, false, wr, inLetExprBody, tr);
      } else if (name == "RotateRight") {
        CompileRotate(e.Receiver, e.Args[0], ">>", "<<", false, true, wr, inLetExprBody, tr);
      } else {
        CompileFunctionCallExpr(e, wr, wr, inLetExprBody, tr);
      }
    }

    void CompileRotate(Expression e0, Expression e1, string op1, string op2, bool truncateOp1, bool truncateOp2, TextWriter wr, bool inLetExprBody, FCE_Arg_Translator tr) {
      NativeType nativeType = AsNativeType(e0.Type);
      bool needsCast = nativeType != null && nativeType.NeedsCastAfterArithmetic;
      // ( e0 op1 e1) | (e0 op2 (width - e1))
      if (needsCast) {
        wr.Write("(" + nativeType.Name + ")(");
      }
      wr.Write("(");
      CompileShift(e0, e1, op1, truncateOp1, nativeType, true, wr, inLetExprBody, tr);
      wr.Write(")");

      wr.Write (" | ");

      wr.Write("(");
      CompileShift(e0, e1, op2, truncateOp2, nativeType, false, wr, inLetExprBody, tr);
      wr.Write(")");

      if (needsCast) {
        wr.Write(")");
      }
    }

    void CompileShift(Expression e0, Expression e1, string op, bool truncate, NativeType nativeType, bool firstOp, TextWriter wr, bool inLetExprBody, FCE_Arg_Translator tr) {
      BitvectorType bv = (BitvectorType)e0.Type;
      bool needsCast = nativeType != null && nativeType.NeedsCastAfterArithmetic;
      if (truncate) {
        BitvectorTruncation(bv, wr, false, true);
      }
      tr(e0, wr, false);
      wr.Write(" {0} ", op);
      if (needsCast) {
        wr.Write("(" + nativeType.Name + ")(");
      }
      if (!firstOp) {
        wr.Write("({0} -", bv.Width);
      }
      tr(e1, wr, inLetExprBody);
      if (!firstOp) {
        wr.Write(")");
      }
      if (needsCast) {
        wr.Write(")");
      }
      if (truncate) {
        BitvectorTruncation(bv, wr, true, true);
      }
    }
    
    void CompileFunctionCallExpr(FunctionCallExpr e, TextWriter twr, TextWriter wr, bool inLetExprBody, FCE_Arg_Translator tr) {
      Contract.Requires(e != null && e.Function != null);
      Contract.Requires(twr != null);
      Contract.Requires(tr != null);
      Function f = e.Function;

      if (f.IsStatic) {
        twr.Write(TypeName_Companion(e.Receiver.Type, wr, e.tok));
      } else {
        twr.Write("(");
        tr(e.Receiver, wr, inLetExprBody);
        twr.Write(")");
      }
      twr.Write(".@{0}", f.CompileName);
      if (f.TypeArgs.Count != 0) {
          List<Type> typeArgs = f.TypeArgs.ConvertAll(ta => e.TypeArgumentSubstitutions[ta]);
          twr.Write("<" + TypeNames(typeArgs, wr, f.tok) + ">");
      }
      twr.Write("(");
      string sep = "";
      for (int i = 0; i < e.Args.Count; i++) {
        if (!e.Function.Formals[i].IsGhost) {
          twr.Write(sep);
          tr(e.Args[i], wr, inLetExprBody);
          sep = ", ";
        }
      }
      twr.Write(")");
    }

    void BetaRedex(List<BoundVar> bvars, List<Expression> exprs, Type bodyType, TextWriter wr, bool inLetExprBody, Action makeBody) {
      Contract.Requires(bvars != null);
      Contract.Requires(exprs != null);
      Contract.Requires(bvars.Count == exprs.Count);
      wr.Write("Dafny.Helpers.Id<");
      wr.Write(TypeName_UDT(ArrowType.Arrow_FullCompileName, Util.Snoc(bvars.ConvertAll(bv => bv.Type), bodyType), wr, Bpl.Token.NoToken));
      wr.Write(">((");
      wr.Write(Util.Comma(bvars, bv => "@" + bv.CompileName));
      wr.Write(") => ");

      makeBody();

      wr.Write(")");
      TrExprList(exprs, wr, inLetExprBody);
    }

  }
}
